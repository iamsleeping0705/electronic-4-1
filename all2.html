<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å­¸è™›æ“¬å¯¦é©—å®¤ (iPadå„ªåŒ–ç‰ˆ)</title>
    <style>
        /* --- ä»‹é¢å¤–æ®¼æ¨£å¼ (Shell Styles) --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* ç¦æ­¢ä¸»é é¢å‡ºç¾å·è»¸ */
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            background-color: #2c3e50;
            /* ç¦æ­¢é¸å–ï¼Œé¿å… iPad é•·æŒ‰é¸å–æ–‡å­— */
            -webkit-user-select: none;
            user-select: none;
        }

        /* 1. åˆå§‹ä¸»é¸å–® */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        #main-menu h1 {
            color: white;
            font-size: 2.8rem;
            margin-bottom: 40px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            letter-spacing: 2px;
            text-align: center;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            max-width: 900px;
            width: 90%;
        }

        .menu-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 35px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .menu-card:hover, .menu-card:active {
            transform: translateY(-8px);
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
        }

        .menu-card h2 { margin: 0 0 10px 0; color: #f1c40f; font-size: 1.6rem; }
        .menu-card p { margin: 0; color: #ecf0f1; font-size: 1rem; opacity: 0.9; }

        /* 2. å¯¦é©—é‹è¡Œå€å®¹å™¨ */
        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #ecf0f1;
            transform: translateY(100%); /* åˆå§‹éš±è—åœ¨ä¸‹æ–¹ */
            transition: transform 0.4s ease-in-out;
        }

        /* Iframe ä½”æ»¿ä¸Šæ–¹å‰©é¤˜ç©ºé–“ï¼Œé‚Šæ¡†æ­¸é›¶ */
        #experiment-frame {
            flex: 1; /* è‡ªå‹•å¡«æ»¿ */
            width: 100%;
            border: none;
            display: block;
            background-color: #fff;
        }

        /* 3. ä¸‹æ–¹å°èˆªåˆ— */
        #bottom-nav {
            height: 65px; /* å›ºå®šé«˜åº¦ */
            background-color: #34495e;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 0 20px;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.15);
            flex-shrink: 0; /* é˜²æ­¢è¢«å£“ç¸® */
            z-index: 50;
            overflow-x: auto; /* å…è¨±å°è¢å¹•æ©«å‘æ²å‹• */
        }

        .nav-btn {
            background: transparent;
            border: 1px solid #7f8c8d;
            color: #bdc3c7;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s;
            white-space: nowrap;
            /* å¢åŠ è§¸æ§ç›®æ¨™å¤§å° */
            min-width: 80px; 
            touch-action: manipulation;
        }

        .nav-btn:hover { background: rgba(255,255,255,0.1); color: #fff; border-color: #fff; }
        
        .nav-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.4);
        }

        .nav-btn.home-btn {
            border-color: #e67e22;
            color: #e67e22;
            margin-right: 20px;
            font-weight: bold;
        }
        .nav-btn.home-btn:hover { background: #e67e22; color: white; border-color: #e67e22; }

        /* ç‹€æ…‹æ§åˆ¶é¡åˆ¥ */
        body.mode-experiment #main-menu { transform: translateY(-100%); }
        body.mode-experiment #app-container { transform: translateY(0); }

        /* éš±è—åŸå§‹ç¢¼å­˜æ”¾å€ */
        .source-code-storage { display: none; }
        
        /* é‡å° iPad ç›´å‘çš„éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-width: 768px) {
            .menu-grid { grid-template-columns: 1fr; gap: 15px; }
            #main-menu h1 { font-size: 2rem; }
            #bottom-nav { justify-content: flex-start; } /* å…è¨±æ²å‹• */
        }
    </style>
</head>
<body>

    <!-- 1. ä¸»é¸å–® -->
    <div id="main-menu">
        <h1>âš¡ éœé›»å­¸è™›æ“¬å¯¦é©—å®¤</h1>
        <div class="menu-grid">
            <div class="menu-card" onclick="loadExperiment(1)">
                <h2>1. æ‘©æ“¦èµ·é›»</h2>
                <p>è§€å¯Ÿé›»è·è½‰ç§»èˆ‡éœé›»å¸å¼•</p>
            </div>
            <div class="menu-card" onclick="loadExperiment(2)">
                <h2>2. éœé›»æ„Ÿæ‡‰</h2>
                <p>å°é«”å…§çš„é›»è·åˆ†é›¢ç¾è±¡</p>
            </div>
            <div class="menu-card" onclick="loadExperiment(3)">
                <h2>3. æ„Ÿæ‡‰èµ·é›»</h2>
                <p>é€éæ¥åœ°ä½¿å°é«”å¸¶é›»</p>
            </div>
            <div class="menu-card" onclick="loadExperiment(4)">
                <h2>4. æ¥è§¸èµ·é›»</h2>
                <p>é›»è·çš„ä¸­å’Œèˆ‡åˆ†é…</p>
            </div>
        </div>
    </div>

    <!-- 2. å¯¦é©—é¡¯ç¤ºå€ -->
    <div id="app-container">
        <iframe id="experiment-frame" title="Experiment Area"></iframe>
        
        <div id="bottom-nav">
            <button class="nav-btn home-btn" onclick="goHome()">ğŸ  ä¸»é¸å–®</button>
            <button class="nav-btn" id="nav-btn-1" onclick="loadExperiment(1)">æ‘©æ“¦èµ·é›»</button>
            <button class="nav-btn" id="nav-btn-2" onclick="loadExperiment(2)">éœé›»æ„Ÿæ‡‰</button>
            <button class="nav-btn" id="nav-btn-3" onclick="loadExperiment(3)">æ„Ÿæ‡‰èµ·é›»</button>
            <button class="nav-btn" id="nav-btn-4" onclick="loadExperiment(4)">æ¥è§¸èµ·é›»</button>
        </div>
    </div>

    <!-- 
      ===============================================================
      3. åŸå§‹ç¢¼å€‰åº«
      ===============================================================
    -->

    <!-- å¯¦é©— 1ï¼šæ‘©æ“¦èµ·é›» (iPad å„ªåŒ–ç‰ˆ) -->
    <textarea id="code-exp-1" class="source-code-storage">
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å¯¦é©—ï¼šæ‘©æ“¦èˆ‡æ„Ÿæ‡‰ (iPadç‰ˆ)</title>
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; background-color: #ecf0f1; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; -webkit-user-select: none; }
        #main-layout { display: flex; gap: 20px; padding: 20px; background-color: #fff; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 1200px; width: 95%; height: 90vh; box-sizing: border-box; }
        #left-panel { flex: 0 0 70%; display: flex; flex-direction: column; gap: 15px; height: 100%; }
        #ui-container { display: flex; gap: 10px; height: 50px; align-items: center; flex-shrink: 0; }
        #canvas-wrapper { position: relative; border-radius: 10px; overflow: hidden; border: 2px solid #bdc3c7; background-color: #f9f9f9; flex: 1; touch-action: none; /* é—œéµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */ }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        #right-panel { flex: 1; display: flex; flex-direction: column; background-color: #fdfefe; border-left: 2px solid #eee; padding-left: 20px; min-width: 250px; overflow-y: auto; }
        .guide-box { background-color: #e8f6f3; border-left: 5px solid #1abc9c; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .guide-title { font-size: 1.2rem; font-weight: bold; color: #16a085; margin-bottom: 10px; display: flex; align-items: center; gap: 5px; }
        .guide-content { font-size: 1rem; line-height: 1.6; color: #34495e; }
        .status-box { background-color: #fff8e1; border: 1px solid #ffe0b2; padding: 15px; border-radius: 8px; margin-top: auto; }
        .progress-text { font-size: 1.5rem; font-weight: bold; color: #e67e22; text-align: center; margin: 10px 0; }
        button { padding: 10px 20px; font-size: 1rem; border: none; border-radius: 8px; cursor: pointer; background-color: #3498db; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s; white-space: nowrap; touch-action: manipulation; }
        button:active { background-color: #2980b9; transform: scale(0.95); }
        button.active { background-color: #2c3e50; border: 2px solid #34495e; }
        #phase-btn { background-color: #e67e22; font-weight: bold; display: none; animation: popIn 0.5s; border: 2px solid #d35400; }
        #phase2-controls { display: none; gap: 10px; }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }
        .highlight { color: #e74c3c; font-weight: bold; }
        .action-tip { color: #2980b9; font-weight: bold; }
    </style>
</head>
<body>
<div id="main-layout">
    <div id="left-panel">
        <div id="ui-container">
            <div id="phase1-controls" style="display:flex; gap:10px; overflow-x:auto;">
                <button id="btn-glass" class="mat-btn active" onclick="setMaterial('glass')">1. ç»æ£’ + çµ²çµ¹</button>
                <button id="btn-plastic" class="mat-btn" onclick="setMaterial('plastic')">2. å¡‘è† æ£’ + æ¯›çš®</button>
            </div>
            <div id="phase2-controls">
                <button id="btn-mode-head" class="active" onclick="setAttractionMode('head')">ğŸ‘± é ­é«®å¸å¼•</button>
                <button id="btn-mode-paper" onclick="setAttractionMode('paper')">ğŸ“„ ç´™å±‘å¸å¼•</button>
            </div>
            <button id="phase-btn" onclick="startAttractionPhase()">ğŸ‘‰ ä¸‹ä¸€æ­¥</button>
            <button id="btn-reset" onclick="resetExperiment()" style="background-color:#95a5a6; margin-left:auto;">é‡ç½®</button>
        </div>
        <div id="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>
    <div id="right-panel">
        <div class="guide-box">
            <div class="guide-title">ğŸ“‹ å¯¦é©—ç›®æ¨™</div>
            <div class="guide-content" id="guide-goal">è«‹é¸æ“‡ä¸€çµ„ææ–™é€²è¡Œæ‘©æ“¦èµ·é›»ã€‚</div>
        </div>
        <div class="guide-box" style="border-left-color: #3498db; background-color: #ebf5fb;">
            <div class="guide-title" style="color: #2980b9;">ğŸ–ï¸ æ“ä½œæŒ‡å°</div>
            <div class="guide-content" id="guide-action">é»æ“Šä¸Šæ–¹æŒ‰éˆ•é–‹å§‹ã€‚</div>
        </div>
        <div class="status-box" id="status-panel">
            <div style="font-weight:bold; color:#7f8c8d; margin-bottom:5px;">é›»å­è½‰ç§»é€²åº¦</div>
            <div class="progress-text" id="progress-display">0 / 10</div>
            <div style="font-size:0.85rem; color:#999; text-align:center;">é¡†é›»å­</div>
        </div>
    </div>
</div>
<script>
const canvas = document.getElementById('simCanvas'); const ctx = canvas.getContext('2d');
// è¨­å®šç•«å¸ƒå¤§å°ç‚ºå®¹å™¨å¤§å°ï¼Œç¢ºä¿åœ¨ iPad ä¸Šæ¸…æ™°
function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    // å¦‚æœå¯¦é©—æ­£åœ¨é€²è¡Œï¼Œå¯èƒ½éœ€è¦é‡æ–°ç¹ªè£½æˆ–é‡ç½®ä½ç½®ï¼Œé€™è£¡ç°¡å–®é‡ç½®æè³ªä»¥ç¢ºä¿ä½ç½®æ­£ç¢º
    if(typeof rod !== 'undefined') setMaterial(materialType);
}
window.addEventListener('resize', resizeCanvas);

let phase = 1; let materialType = 'glass'; let attractionMode = 'head'; let particles = []; let rod = {}; let cloth = {}; let head = null; let papers = [];
let draggingObj = null; let dragOffset = {x: 0, y: 0}; let lastMouseY = 0; let rodVelocity = {x:0, y:0}; let isTouchingRod = false; let touchSide = null; 
const CHARGE_COUNT = 10; const PARTICLE_RADIUS = 8;

function updateGuideText() {
    const goalEl = document.getElementById('guide-goal'); const actionEl = document.getElementById('guide-action'); const statusPanel = document.getElementById('status-panel'); const progressDisplay = document.getElementById('progress-display');
    if (phase === 1) {
        statusPanel.style.display = 'block';
        let transferProgress = 0;
        if (materialType === 'glass') { let clothNeg = particles.filter(p => p.parent === 'cloth' && p.charge === -1).length; transferProgress = clothNeg - 10; } 
        else { let rodNeg = particles.filter(p => p.parent === 'rod' && p.charge === -1).length; transferProgress = rodNeg - 10; }
        transferProgress = Math.max(0, transferProgress); progressDisplay.innerText = `${transferProgress} / ${CHARGE_COUNT}`;
        if (materialType === 'glass') { goalEl.innerHTML = "è®“<span class='highlight'>ç»ç’ƒæ£’</span>å¤±å»é›»å­ï¼Œå¸¶<span class='highlight'>æ­£é›»</span>ã€‚"; } else { goalEl.innerHTML = "è®“<span class='highlight'>å¡‘è† æ£’</span>å¾—åˆ°é›»å­ï¼Œå¸¶<span class='highlight'>è² é›»</span>ã€‚"; }
        if (transferProgress < CHARGE_COUNT) { actionEl.innerHTML = "1. æ‹–æ›³å¸ƒæ–™åˆ°æ£’å­<span class='highlight'>å·¦å´æˆ–å³å´</span>è¡¨é¢ã€‚<br>2. <span class='action-tip'>ä¸Šä¸‹æ‘©æ“¦</span>æ¥è§¸é¢ã€‚<br>3. æ³¨æ„ï¼šé›»å­åªæœƒå¾<span class='highlight'>æ‘©æ“¦åˆ°çš„ä½ç½®</span>ç§»å‹•ï¼"; } 
        else { actionEl.innerHTML = "âœ… æ­å–œï¼é›»å­å·²å…¨éƒ¨è½‰ç§»ã€‚<br>è«‹é»æ“Šä¸Šæ–¹æ©˜è‰²æŒ‰éˆ• <span class='highlight'>ä¸‹ä¸€æ­¥</span> é€²è¡Œéœé›»å¸å¼•å¯¦é©—ã€‚"; }
    } else {
        statusPanel.style.display = 'none';
        if (attractionMode === 'head') { goalEl.innerHTML = "è§€å¯Ÿå¸¶é›»é«”å°<span class='highlight'>é ­é«®</span>çš„éœé›»æ„Ÿæ‡‰èˆ‡å¸å¼•åŠ›ã€‚"; actionEl.innerHTML = "1. æ‹–æ›³å¸¶é›»é«”(æ£’å­/å¸ƒ)é è¿‘äººé ­ã€‚<br>2. å˜—è©¦<span class='action-tip'>æ¥µåº¦é è¿‘</span>é ­é ‚ã€‚<br>3. è§€å¯Ÿé ­é«®çš„<span class='highlight'>åŠ‡çƒˆæŠ–å‹•</span>èˆ‡è¡¨æƒ…è®ŠåŒ–ã€‚"; } 
        else { goalEl.innerHTML = "è§€å¯Ÿå¸¶é›»é«”å¸é™„<span class='highlight'>å°ç´™å±‘</span>åŠå…¶é›£ä»¥ç”©è„«çš„ç‰¹æ€§ã€‚"; actionEl.innerHTML = "1. æ‹–æ›³å¸¶é›»é«”é è¿‘åœ°é¢å¸èµ·ç´™å±‘ã€‚<br>2. å˜—è©¦ç§»å‹•æ»‘é¼ /æ‰‹æŒ‡å°‡ç´™å±‘ç”©æ‰ã€‚<br>3. æç¤ºï¼šå¿…é ˆ<span class='highlight'>å¿«é€Ÿç”¨åŠ›ç”©å‹•</span>æ‰èƒ½ç”©é–‹å®ƒå€‘ï¼"; }
    }
}
class Particle {
    constructor(x, y, charge, parent) { this.charge = charge; this.parent = parent; this.currentX = x; this.currentY = y; if (parent === 'rod') { this.relX = x - rod.x; this.relY = y - rod.y; } else { this.relX = x - cloth.x; this.relY = y - cloth.y; } this.isMoving = false; this.targetParentName = null; this.targetRelX = 0; this.targetRelY = 0; this.moveProgress = 0; this.startX = 0; this.startY = 0; }
    startTransfer(targetName, tx, ty) { if (this.isMoving) return; this.isMoving = true; this.targetParentName = targetName; this.moveProgress = 0; this.startX = this.currentX; this.startY = this.currentY; let tObj = (targetName === 'rod') ? rod : cloth; this.targetRelX = tx - tObj.x; this.targetRelY = ty - tObj.y; setTimeout(checkProgress, 500); }
    update() { if (this.isMoving) { this.moveProgress += 0.15; if (this.moveProgress >= 1) this.moveProgress = 1; let tObj = (this.targetParentName === 'rod') ? rod : cloth; let destX = tObj.x + this.targetRelX; let destY = tObj.y + this.targetRelY; this.currentX = this.startX + (destX - this.startX) * this.moveProgress; this.currentY = this.startY + (destY - this.startY) * this.moveProgress; if (this.moveProgress === 1) { this.isMoving = false; this.parent = this.targetParentName; this.relX = this.targetRelX; this.relY = this.targetRelY; checkProgress(); } } else { let pObj = (this.parent === 'rod') ? rod : cloth; this.currentX = pObj.x + this.relX; this.currentY = pObj.y + this.relY; } }
    draw() { ctx.beginPath(); ctx.arc(this.currentX, this.currentY, PARTICLE_RADIUS, 0, Math.PI * 2); if (this.charge > 0) { ctx.fillStyle = '#e74c3c'; ctx.shadowColor = 'rgba(231, 76, 60, 0.5)'; } else { ctx.fillStyle = '#3498db'; ctx.shadowColor = 'rgba(255, 255, 255, 0.8)'; ctx.shadowBlur = 4; } ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.charge > 0 ? '+' : '-', this.currentX, this.currentY + 1); }
}
class Hair {
    constructor(rootX, rootY, length) { this.rootX = rootX; this.rootY = rootY; this.len = length; this.currentTipX = 0; this.currentTipY = 0; }
    update(headX, headY) { const worldRootX = headX + this.rootX; const worldRootY = headY + this.rootY; let totalFx = 0, totalFy = 0, totalForceMag = 0; const addForce = (obj) => { let netCharge = particles.reduce((sum, p) => (p.parent === (obj === rod ? 'rod' : 'cloth')) ? sum + p.charge : sum, 0); if (netCharge === 0) return; let centerX = obj.x + obj.w/2; let centerY = obj.y + obj.h/2; let dx = centerX - worldRootX; let dy = centerY - worldRootY; let distSq = dx*dx + dy*dy; if (distSq < 300000) { let force = Math.abs(netCharge) * 300000 / (distSq + 2000); let dist = Math.sqrt(distSq); totalFx += (dx / dist) * force; totalFy += (dy / dist) * force; totalForceMag += force; } }; addForce(rod); addForce(cloth); let targetX = worldRootX + Math.cos(-Math.PI/2) * this.len; let targetY = worldRootY + Math.sin(-Math.PI/2) * this.len; targetX += totalFx; targetY += totalFy; if (totalForceMag > 0) { let jitterAmount = totalForceMag * 0.6; targetX += (Math.random() - 0.5) * jitterAmount; targetY += (Math.random() - 0.5) * jitterAmount; } let dx = targetX - worldRootX; let dy = targetY - worldRootY; let currentLen = Math.sqrt(dx*dx + dy*dy); if (currentLen > this.len) { targetX = worldRootX + (dx/currentLen) * this.len; targetY = worldRootY + (dy/currentLen) * this.len; } this.currentTipX += (targetX - this.currentTipX) * 0.25; this.currentTipY += (targetY - this.currentTipY) * 0.25; return totalForceMag; }
    draw(ctx, headX, headY) { const worldRootX = headX + this.rootX; const worldRootY = headY + this.rootY; ctx.beginPath(); ctx.moveTo(worldRootX, worldRootY); let cx = (worldRootX + this.currentTipX)/2; let cy = (worldRootY + this.currentTipY)/2 - 5; ctx.quadraticCurveTo(cx, cy, this.currentTipX, this.currentTipY); ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke(); }
}
class PaperScrap {
    constructor() { this.w = 12 + Math.random() * 8; this.h = 8 + Math.random() * 6; this.x = 50 + Math.random() * 400; this.y = canvas.height - 20 - Math.random() * 30; this.angle = Math.random() * Math.PI; this.color = `hsl(${35 + Math.random()*20}, 90%, 65%)`; this.vx = 0; this.vy = 0; this.state = 'ground'; this.stuckObj = null; this.relX = 0; this.relY = 0; this.ignoreAttractionTimer = 0; }
    update() { if (this.ignoreAttractionTimer > 0) this.ignoreAttractionTimer--; if (this.state === 'ground' || this.state === 'falling') { if (this.state === 'falling') { this.vy += 0.8; this.x += this.vx; this.y += this.vy; this.vx *= 0.92; if (this.x < 0) { this.x = 0; this.vx *= -0.5; } if (this.x > canvas.width - this.w) { this.x = canvas.width - this.w; this.vx *= -0.5; } if (this.y > canvas.height - 20) { this.y = canvas.height - 20; this.vy = 0; this.vx = 0; this.state = 'ground'; } } if (this.ignoreAttractionTimer === 0) { let attracted = false; [rod, cloth].forEach(obj => { if (attracted) return; let netCharge = particles.reduce((sum, p) => (p.parent === (obj === rod ? 'rod' : 'cloth')) ? sum + p.charge : sum, 0); if (Math.abs(netCharge) > 0) { let cx = obj.x + obj.w/2; let cy = obj.y + obj.h/2; let dist = Math.sqrt((cx - this.x)**2 + (cy - this.y)**2); let baseThreshold = 200 + Math.abs(netCharge) * 15; let threshold = (this.state === 'falling') ? 120 : baseThreshold; if (dist < threshold) { this.state = 'flying'; this.vy = -4; attracted = true; } } }); } } if (this.state === 'flying') { let target = null; let minDist = Infinity; [rod, cloth].forEach(obj => { let netCharge = particles.reduce((sum, p) => (p.parent === (obj === rod ? 'rod' : 'cloth')) ? sum + p.charge : sum, 0); if (Math.abs(netCharge) > 0) { let cx = obj.x + obj.w/2; let cy = obj.y + obj.h/2; let dist = Math.sqrt((cx - this.x)**2 + (cy - this.y)**2); if (dist < minDist) { minDist = dist; target = obj; } } }); if (target) { let cx = target.x + target.w/2; let cy = target.y + target.h/2; let dx = cx - this.x; let dy = cy - this.y; let dist = Math.sqrt(dx*dx + dy*dy); this.vx += (dx/dist) * 3.5; this.vy += (dy/dist) * 3.5; this.vx *= 0.92; this.vy *= 0.92; this.x += this.vx; this.y += this.vy; this.angle += this.vx * 0.1; if (checkOverlap(this.x, this.y, this.w, this.h, target.x, target.y, target.w, target.h)) { this.state = 'stuck'; this.stuckObj = target; this.relX = this.x - target.x; this.relY = this.y - target.y; } } else { this.state = 'falling'; } } if (this.state === 'stuck' && this.stuckObj) { this.x = this.stuckObj.x + this.relX; this.y = this.stuckObj.y + this.relY; let speed = Math.sqrt(rodVelocity.x**2 + rodVelocity.y**2); if (this.stuckObj === draggingObj && speed > 35) { if (Math.random() > 0.85) { this.state = 'falling'; let throwVx = rodVelocity.x + (Math.random()-0.5)*10; let throwVy = rodVelocity.y + (Math.random()-0.5)*10; if (throwVx > 20) throwVx = 20; if (throwVx < -20) throwVx = -20; if (throwVy > 20) throwVy = 20; if (throwVy < -20) throwVy = -20; this.vx = throwVx; this.vy = throwVy; this.stuckObj = null; this.ignoreAttractionTimer = 45; } } } }
    draw() { ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 3; ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h); ctx.restore(); }
}
function resetExperiment() { phase = 1; particles = []; draggingObj = null; head = null; papers = []; attractionMode = 'head'; document.getElementById('phase-btn').style.display = 'none'; document.getElementById('phase1-controls').style.display = 'flex'; document.getElementById('phase2-controls').style.display = 'none'; setMaterial(materialType); }
function setMaterial(type) { materialType = type; particles = []; document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active')); document.getElementById(type === 'glass' ? 'btn-glass' : 'btn-plastic').classList.add('active'); document.getElementById('phase-btn').style.display = 'none'; rod = { x: canvas.width/2 - 25, y: 100, w: 50, h: 300, color: type === 'glass' ? 'rgba(200, 230, 255, 0.9)' : '#555555', name: type === 'glass' ? 'ç»æ£’' : 'å¡‘è† æ£’', draggable: false }; cloth = { x: canvas.width/2 + 60, y: 180, w: 120, h: 120, color: type === 'glass' ? '#e84393' : '#d35400', name: type === 'glass' ? 'çµ²çµ¹' : 'æ¯›çš®', draggable: true }; for (let i = 0; i < CHARGE_COUNT; i++) { let py = rod.y + 30 + (i * (rod.h - 60) / (CHARGE_COUNT - 1)); particles.push(new Particle(rod.x + rod.w/2, py, 1, 'rod')); } for (let i = 0; i < CHARGE_COUNT; i++) { let isLeft = (i % 2 === 0); let px = isLeft ? rod.x + rod.w * 0.2 : rod.x + rod.w * 0.8; let py = rod.y + 30 + (i * (rod.h - 60) / (CHARGE_COUNT - 1)); particles.push(new Particle(px, py, -1, 'rod')); } for (let i = 0; i < CHARGE_COUNT * 2; i++) { let isPos = i < CHARGE_COUNT; let px = cloth.x + 15 + Math.random()*(cloth.w-30); let py = cloth.y + 15 + Math.random()*(cloth.h-30); particles.push(new Particle(px, py, isPos ? 1 : -1, 'cloth')); } updateGuideText(); }
function checkProgress() { let rodNeg = particles.filter(p => p.parent === 'rod' && p.charge === -1).length; let clothNeg = particles.filter(p => p.parent === 'cloth' && p.charge === -1).length; let isComplete = false; if (materialType === 'glass') { if (rodNeg === 0) isComplete = true; } else { if (clothNeg === 0) isComplete = true; } if (isComplete) { document.getElementById('phase-btn').style.display = 'block'; } updateGuideText(); }
function startAttractionPhase() { phase = 2; document.getElementById('phase-btn').style.display = 'none'; document.getElementById('phase1-controls').style.display = 'none'; document.getElementById('phase2-controls').style.display = 'flex'; rod.draggable = true; rod.x = canvas.width - 150; rod.y = 100; cloth.draggable = true; cloth.x = canvas.width - 150; cloth.y = 350; particles.forEach(p => { if (p.parent === 'rod') { p.relX = Math.min(Math.max(p.relX, 0), rod.w); p.currentX = rod.x + p.relX; p.currentY = rod.y + p.relY; } else { p.relX = Math.min(Math.max(p.relX, 0), cloth.w); p.currentX = cloth.x + p.relX; p.currentY = cloth.y + p.relY; } }); setAttractionMode('head'); }
function setAttractionMode(mode) { attractionMode = mode; document.getElementById('btn-mode-head').classList.toggle('active', mode === 'head'); document.getElementById('btn-mode-paper').classList.toggle('active', mode === 'paper'); if (mode === 'head') { head = { x: 100, y: canvas.height - 120, r: 60, hairs: [], expressionStrength: 0, shakeX: 0, shakeY: 0 }; for(let i=0; i<15; i++) { let angle = -Math.PI + (Math.PI/14)*i; let rx = Math.cos(angle) * head.r; let ry = Math.sin(angle) * head.r; if (ry > -20) ry = -20; head.hairs.push(new Hair(rx, ry, 40 + Math.random()*20)); } papers = []; } else { head = null; papers = []; for(let i=0; i<40; i++) papers.push(new PaperScrap()); } updateGuideText(); }
function roundRect(ctx, x, y, width, height, radius, fill, stroke) { if (typeof stroke === 'undefined') stroke = true; if (typeof radius === 'undefined') radius = 5; ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); if (stroke) ctx.stroke(); if (fill) ctx.fill(); }
function drawChargeText(obj) { let charge = particles.reduce((sum, p) => (p.parent === (obj === rod ? 'rod' : 'cloth')) ? sum + p.charge : sum, 0); let chargeStr = `(${charge > 0 ? '+' : ''}${charge})`; let label = obj.name + " " + chargeStr; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; let nameWidth = ctx.measureText(obj.name + " ").width; let fullWidth = ctx.measureText(label).width; let startX = obj.x + obj.w/2 - fullWidth/2; let textY = obj.y - 15; ctx.fillStyle = '#555'; ctx.textAlign = 'left'; ctx.fillText(obj.name + " ", startX, textY); if (charge > 0) ctx.fillStyle = '#e74c3c'; else if (charge < 0) ctx.fillStyle = '#3498db'; else ctx.fillStyle = '#95a5a6'; ctx.fillText(chargeStr, startX + nameWidth, textY); }
function drawHead() { if (!head) return; let totalForce = 0; head.hairs.forEach(h => { let f = h.update(head.x + head.shakeX, head.y + head.shakeY); totalForce += f; h.draw(ctx, head.x + head.shakeX, head.y + head.shakeY); }); let getDist = (obj) => { let cx = obj.x + obj.w/2; let cy = obj.y + obj.h/2; return Math.sqrt((cx - head.x)**2 + (cy - head.y)**2); }; let minDist = Math.min(getDist(rod), getDist(cloth)); let expressionLevel = 0; if (minDist > 350) expressionLevel = 0; else if (minDist > 180) expressionLevel = 1; else expressionLevel = 2; let shockFactor = Math.min(totalForce / 80, 1.2); if (expressionLevel === 2 && shockFactor > 0.5) { head.shakeX = (Math.random() - 0.5) * 2; head.shakeY = (Math.random() - 0.5) * 2; } else { head.shakeX = 0; head.shakeY = 0; } let drawX = head.x + head.shakeX; let drawY = head.y + head.shakeY; ctx.beginPath(); ctx.arc(drawX, drawY, head.r, 0, Math.PI*2); ctx.fillStyle = '#f1c40f'; ctx.fill(); ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 3; ctx.stroke(); ctx.fillStyle = 'black'; let eyeR = (expressionLevel === 2) ? 12 : (expressionLevel === 1 ? 8 : 6); ctx.beginPath(); ctx.arc(drawX - 20, drawY - 10, eyeR, 0, Math.PI*2); ctx.arc(drawX + 20, drawY - 10, eyeR, 0, Math.PI*2); ctx.fill(); ctx.lineWidth = 2; ctx.beginPath(); if (expressionLevel > 0) { ctx.moveTo(drawX - 30, drawY - 25); ctx.lineTo(drawX - 10, drawY - 30); ctx.moveTo(drawX + 10, drawY - 30); ctx.lineTo(drawX + 30, drawY - 25); } else { ctx.moveTo(drawX - 30, drawY - 20); ctx.lineTo(drawX - 10, drawY - 20); ctx.moveTo(drawX + 10, drawY - 20); ctx.lineTo(drawX + 30, drawY - 20); } ctx.stroke(); ctx.fillStyle = '#c0392b'; ctx.beginPath(); if (expressionLevel === 0) { ctx.moveTo(drawX - 15, drawY + 20); ctx.quadraticCurveTo(drawX, drawY + 25, drawX + 15, drawY + 20); ctx.fill(); } else if (expressionLevel === 1) { ctx.ellipse(drawX, drawY + 25, 8, 12, 0, 0, Math.PI*2); ctx.fill(); } else { ctx.ellipse(drawX, drawY + 28, 12, 20, 0, 0, Math.PI*2); ctx.fill(); } }
function update() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); let grad = ctx.createLinearGradient(rod.x, 0, rod.x + rod.w, 0); if (materialType === 'glass') { grad.addColorStop(0, 'rgba(230, 245, 255, 0.8)'); grad.addColorStop(1, 'rgba(200, 230, 255, 0.8)'); } else { grad.addColorStop(0, '#555'); grad.addColorStop(1, '#333'); } ctx.fillStyle = grad; ctx.strokeStyle = '#999'; ctx.lineWidth = 2; roundRect(ctx, rod.x, rod.y, rod.w, rod.h, 15, true, true); ctx.restore(); drawChargeText(rod); ctx.save(); ctx.fillStyle = cloth.color; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 10; roundRect(ctx, cloth.x, cloth.y, cloth.w, cloth.h, 10, true, false); ctx.restore(); drawChargeText(cloth); if (phase === 2) { if (attractionMode === 'head') drawHead(); else if (attractionMode === 'paper') papers.forEach(p => { p.update(); p.draw(); }); } particles.forEach(p => { p.update(); p.draw(); }); requestAnimationFrame(update); }
canvas.addEventListener('mousedown', (e) => { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; let target = null; if (checkHit(mx, my, cloth) && cloth.draggable) target = cloth; else if (checkHit(mx, my, rod) && rod.draggable) target = rod; if (target) { draggingObj = target; dragOffset.x = mx - target.x; dragOffset.y = my - target.y; lastMouseY = my; lastRodPos = {x: target.x, y: target.y}; } });
function checkHit(mx, my, obj) { return mx > obj.x && mx < obj.x + obj.w && my > obj.y && my < obj.y + obj.h; }
canvas.addEventListener('mousemove', (e) => { 
    const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
    let isHovering = false;
    if (checkHit(mx, my, cloth) && cloth.draggable) isHovering = true;
    else if (checkHit(mx, my, rod) && rod.draggable) isHovering = true;
    if (isHovering || draggingObj) { canvas.style.cursor = 'pointer'; } else { canvas.style.cursor = 'default'; }
    if (!draggingObj) return; 
    let nextX = mx - dragOffset.x; let nextY = my - dragOffset.y; rodVelocity = { x: nextX - draggingObj.x, y: nextY - draggingObj.y }; if (phase === 1 && draggingObj === cloth) { isTouchingRod = false; touchSide = null; if (checkOverlap(nextX, nextY, cloth.w, cloth.h, rod.x, rod.y, rod.w, rod.h)) { let clothCx = nextX + cloth.w/2; let rodCx = rod.x + rod.w/2; if (clothCx < rodCx) { nextX = rod.x - cloth.w; touchSide = 'left'; } else { nextX = rod.x + rod.w; touchSide = 'right'; } isTouchingRod = true; } cloth.x = nextX; cloth.y = nextY; checkFriction(my); } else { draggingObj.x = nextX; draggingObj.y = nextY; } lastMouseY = my; 
});
window.addEventListener('mouseup', () => { draggingObj = null; isTouchingRod = false; rodVelocity = {x:0, y:0}; });
function checkOverlap(x1, y1, w1, h1, x2, y2, w2, h2) { return (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2); }
function checkFriction(currentMouseY) { if (!isTouchingRod || !touchSide) return; if (Math.abs(currentMouseY - lastMouseY) < 5) return; let frictionTop = cloth.y; let frictionBottom = cloth.y + cloth.h; if (Math.random() > 0.92) transferElectron(touchSide, frictionTop, frictionBottom); }
function transferElectron(side, frictionTop, frictionBottom) { let sourceList, targetName; if (materialType === 'glass') { sourceList = particles.filter(p => { if (p.parent !== 'rod' || p.charge !== -1) return false; if (side === 'left' && p.relX >= rod.w/2) return false; if (side === 'right' && p.relX <= rod.w/2) return false; if (p.currentY < frictionTop - 10 || p.currentY > frictionBottom + 10) return false; return true; }); targetName = 'cloth'; } else { sourceList = particles.filter(p => p.parent === 'cloth' && p.charge === -1); targetName = 'rod'; } if (sourceList.length === 0) return; let electron = sourceList[Math.floor(Math.random() * sourceList.length)]; let tx, ty; if (targetName === 'rod') { let validSide = side || 'left'; let minX = (validSide === 'left') ? 0 : rod.w * 0.4; let maxX = (validSide === 'left') ? rod.w * 0.6 : rod.w; let rx = minX + Math.random() * (maxX - minX); let ry = Math.random() * (rod.h - 20) + 10; tx = rod.x + rx; ty = rod.y + ry; } else { tx = cloth.x + 10 + Math.random()*(cloth.w-20); ty = cloth.y + 10 + Math.random()*(cloth.h-20); } electron.startTransfer(targetName, tx, ty); }

// --- iPad Touch Event Support ---
// å°‡è§¸æ§äº‹ä»¶æ˜ å°„ç‚ºæ»‘é¼ äº‹ä»¶ï¼Œè®“ç¨‹å¼ç¢¼åœ¨ iPad ä¸Šä¹Ÿèƒ½é‹ä½œ
canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length > 1) return; // å¿½ç•¥å¤šé»è§¸æ§
    e.preventDefault(); // é˜²æ­¢ç•«é¢æ²å‹•
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousedown', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchmove', function(e) {
    e.preventDefault(); // é˜²æ­¢ç•«é¢æ²å‹•
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousemove', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    var mouseEvent = new MouseEvent('mouseup', {
        bubbles: true, cancelable: true, view: window
    });
    window.dispatchEvent(mouseEvent);
}, {passive: false});

resizeCanvas();
setMaterial('glass'); update();
</script>
</body>
</html>
    </textarea>

    <!-- å¯¦é©— 2ï¼šéœé›»æ„Ÿæ‡‰ (iPad å„ªåŒ–ç‰ˆ) -->
    <textarea id="code-exp-2" class="source-code-storage">
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å¯¦é©— 2ï¼šéœé›»æ„Ÿæ‡‰ (iPadç‰ˆ)</title>
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; background-color: #ecf0f1; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; -webkit-user-select: none; }
        #main-layout { display: flex; gap: 20px; padding: 20px; background-color: #fff; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 1200px; width: 95%; height: 90vh; box-sizing: border-box; }
        #left-panel { flex: 0 0 70%; display: flex; flex-direction: column; gap: 15px; height: 100%; }
        #ui-container { display: flex; gap: 10px; height: 50px; align-items: center; flex-shrink: 0; }
        #canvas-wrapper { position: relative; border-radius: 10px; overflow: hidden; border: 2px solid #bdc3c7; background-color: #f9f9f9; flex: 1; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        #right-panel { flex: 1; display: flex; flex-direction: column; background-color: #fdfefe; border-left: 2px solid #eee; padding-left: 20px; min-width: 250px; overflow-y: auto; }
        .guide-box { background-color: #e8f6f3; border-left: 5px solid #1abc9c; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .guide-title { font-size: 1.2rem; font-weight: bold; color: #16a085; margin-bottom: 10px; display: flex; align-items: center; gap: 5px; }
        .guide-content { font-size: 1rem; line-height: 1.6; color: #34495e; }
        button { padding: 10px 20px; font-size: 1rem; border: none; border-radius: 8px; cursor: pointer; background-color: #3498db; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s; white-space: nowrap; touch-action: manipulation; }
        button:hover { background-color: #2980b9; transform: translateY(-1px); }
        button.active { background-color: #2c3e50; border: 2px solid #34495e; }
        .pos-text { color: #e74c3c; font-weight: bold; }
        .neg-text { color: #3498db; font-weight: bold; }
    </style>
</head>
<body>
<div id="main-layout">
    <div id="left-panel">
        <div id="ui-container">
            <button id="btn-plastic" class="mat-btn active" onclick="setRodType('plastic')">1. è² é›»å¡‘è† æ£’ (-)</button>
            <button id="btn-glass" class="mat-btn" onclick="setRodType('glass')">2. æ­£é›»ç»ç’ƒæ£’ (+)</button>
            <button id="btn-reset" onclick="resetExperiment()" style="background-color:#95a5a6; margin-left:auto;">é‡ç½®ä½ç½®</button>
        </div>
        <div id="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>
    <div id="right-panel">
        <div class="guide-box">
            <div class="guide-title">ğŸ“‹ å¯¦é©—åŸç†</div>
            <div class="guide-content" id="guide-principle">è§€å¯Ÿç•«é¢èƒŒæ™¯çš„é¡è‰²è®ŠåŒ–ï¼š<br><span class="pos-text">â–  ç´…è‰²å€åŸŸ</span> ä»£è¡¨æ„Ÿæ‡‰å‡ºæ­£é›»<br><span class="neg-text">â–  è—è‰²å€åŸŸ</span> ä»£è¡¨æ„Ÿæ‡‰å‡ºè² é›»<br><br>ç•¶é‡‘å±¬çƒè®Šç‚º<span style="color:#27ae60; font-weight:bold;">ç¶ è‰²å¤–æ¡†</span>æ™‚ï¼Œä»£è¡¨é›–ç„¶é›»è·åˆ†é›¢ï¼Œä½†<b>ç¸½é›»é‡ä¾ç„¶ç¶­æŒä¸è®Šï¼ˆä¸­æ€§ï¼‰</b>ã€‚</div>
        </div>
        <div class="guide-box" style="border-left-color: #3498db; background-color: #ebf5fb;">
            <div class="guide-title" style="color: #2980b9;">ğŸ–ï¸ æ“ä½œæŒ‡å°</div>
            <div class="guide-content" id="guide-action">è«‹æ‹–æ›³æ£’å­é è¿‘é‡‘å±¬çƒã€‚</div>
        </div>
    </div>
</div>
<script>
const canvas = document.getElementById('simCanvas'); const ctx = canvas.getContext('2d');
function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    if(typeof sphere !== 'undefined') {
        sphere.x = canvas.width * 0.65; // ä¿æŒçƒåœ¨å³å´
        sphere.y = canvas.height / 2;
        init(); // é‡ç½®ä½ç½®
    }
}
window.addEventListener('resize', resizeCanvas);

let rodType = 'plastic'; let rod = {}; let sphere = {}; let particles = []; let draggingObj = null; let dragOffset = {x: 0, y: 0};
const PARTICLE_RADIUS = 7; const SPHERE_RADIUS = 90; const GRID_SPACING = 35; const MIN_GAP = 20; 
class Particle {
    constructor(x, y, charge, parent, isFixed = false) { this.charge = charge; this.parent = parent; this.isFixed = isFixed; this.baseX = x; this.baseY = y; this.currentX = parent === 'rod' ? rod.x + x : sphere.x + x; this.currentY = parent === 'rod' ? rod.y + y : sphere.y + y; }
    update() { if (this.parent === 'rod') { this.currentX = rod.x + this.baseX; this.currentY = rod.y + this.baseY; } else if (this.parent === 'sphere') { const sphereCx = sphere.x; const sphereCy = sphere.y; if (this.isFixed) { this.currentX = sphereCx + this.baseX; this.currentY = sphereCy + this.baseY; } else { let rodCharge = (rodType === 'glass') ? 1 : -1; let rodEffectX = rod.x + rod.w; let rodEffectY = rod.y + rod.h/2; let dx = rodEffectX - sphereCx; let dy = rodEffectY - sphereCy; let dist = Math.sqrt(dx*dx + dy*dy); const MIN_DIST = SPHERE_RADIUS + MIN_GAP; const MAX_DIST = 210; let t = 0; if (dist < MAX_DIST) { t = 1 - (dist - MIN_DIST) / (MAX_DIST - MIN_DIST); if (t > 1) t = 1; if (t < 0) t = 0; } let targetX, targetY; if (t > 0.01) { let dirX, dirY; if (rodCharge === 1) { dirX = dx; dirY = dy; } else { dirX = -dx; dirY = -dy; } let len = Math.sqrt(dirX*dirX + dirY*dirY); dirX /= len; dirY /= len; let boundaryR = SPHERE_RADIUS - 8; let spreadAngle = (Math.random() - 0.5) * 1.5; let cosA = Math.cos(spreadAngle); let sinA = Math.sin(spreadAngle); let finalDirX = dirX * cosA - dirY * sinA; let finalDirY = dirX * sinA + dirY * cosA; let edgeX = sphereCx + finalDirX * boundaryR; let edgeY = sphereCy + finalDirY * boundaryR; let easeT = t * t * t; targetX = (sphereCx + this.baseX) * (1 - easeT) + edgeX * easeT; targetY = (sphereCy + this.baseY) * (1 - easeT) + edgeY * easeT; } else { targetX = sphereCx + this.baseX; targetY = sphereCy + this.baseY; } this.currentX += (targetX - this.currentX) * 0.1; this.currentY += (targetY - this.currentY) * 0.1; } } }
    draw() { ctx.beginPath(); ctx.arc(this.currentX, this.currentY, PARTICLE_RADIUS, 0, Math.PI * 2); if (this.charge > 0) { ctx.fillStyle = '#e74c3c'; } else { ctx.fillStyle = '#3498db'; } ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.charge > 0 ? '+' : '-', this.currentX, this.currentY + 1); }
}
function init() { 
    rod = { x: 40, y: canvas.height/2 - 25, w: 220, h: 50, name: 'è² é›»å¡‘è† æ£’', draggable: true }; 
    if(!sphere.x) sphere = { x: canvas.width * 0.65, y: canvas.height/2, r: SPHERE_RADIUS, name: 'é‡‘å±¬çƒ', draggable: false }; 
    else sphere.y = canvas.height/2; // ç¢ºä¿é«˜åº¦ç½®ä¸­
    setRodType('plastic'); 
}
function setRodType(type) { rodType = type; particles = []; document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active')); document.getElementById(type === 'glass' ? 'btn-glass' : 'btn-plastic').classList.add('active'); if (type === 'plastic') { rod.name = 'è² é›»å¡‘è† æ£’'; let excessCount = 12; let margin = 10; let w = rod.w - 2 * margin; let h = rod.h - 2 * margin; let perimeter = 2 * (w + h); let step = perimeter / excessCount; for(let i=0; i<excessCount; i++) { let pos = i * step; let tx, ty; if (pos < w) { tx = margin + pos; ty = margin; } else if (pos < w + h) { tx = margin + w; ty = margin + (pos - w); } else if (pos < 2 * w + h) { tx = margin + w - (pos - (w + h)); ty = margin + h; } else { tx = margin; ty = margin + h - (pos - (2 * w + h)); } particles.push(new Particle(tx, ty, -1, 'rod')); } } else { rod.name = 'æ­£é›»ç»ç’ƒæ£’'; let rows = 2; let cols = 6; let startX = rod.w * 0.15; let stepX = (rod.w * 0.7) / (cols - 1); let startY = rod.h * 0.35; let stepY = rod.h * 0.3; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { let px = startX + c * stepX; let py = startY + r * stepY; particles.push(new Particle(px, py, 1, 'rod')); } } } for(let y = -SPHERE_RADIUS; y <= SPHERE_RADIUS; y += GRID_SPACING) { for(let x = -SPHERE_RADIUS; x <= SPHERE_RADIUS; x += GRID_SPACING) { if (x*x + y*y < (SPHERE_RADIUS - 15)**2) { particles.push(new Particle(x, y, 1, 'sphere', true)); particles.push(new Particle(x, y, -1, 'sphere', false)); } } } }
function resetExperiment() { rod.x = 40; rod.y = canvas.height/2 - 25; }
function roundRect(ctx, x, y, width, height, radius, fill, stroke) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); if (stroke) ctx.stroke(); if (fill) ctx.fill(); }
function drawLabel(ctx, text, x, y, chargeType) { ctx.save(); ctx.font = "bold 24px Arial"; ctx.textAlign = "center"; if (chargeType > 0) ctx.fillStyle = "#e74c3c"; else if (chargeType < 0) ctx.fillStyle = "#3498db"; else ctx.fillStyle = "#2c3e50"; let sign = ""; if (chargeType > 0) sign = " (+)"; else if (chargeType < 0) sign = " (-)"; ctx.fillText(text + sign, x, y); ctx.restore(); }
function updateGuide() { let rodRight = rod.x + rod.w; let sphereLeft = sphere.x - sphere.r; let dist = sphereLeft - rodRight; let actionText = ""; if (dist > 100) { actionText = "è«‹æ‹–æ›³æ£’å­é è¿‘å³é‚Šçš„é‡‘å±¬çƒã€‚"; } else { actionText = "è§€å¯Ÿé›»å­ç§»å‹•ï¼<br>"; if (rodType === 'glass') { actionText += "æ­£é›»æ£’å¸å¼•é›»å­ï¼Œå·¦å´è®Š<span class='neg-text'>è² é›»</span>ï¼Œå³å´è®Š<span class='pos-text'>æ­£é›»</span>ã€‚"; } else { actionText += "è² é›»æ£’æ’æ–¥é›»å­ï¼Œå·¦å´è®Š<span class='pos-text'>æ­£é›»</span>ï¼Œå³å´è®Š<span class='neg-text'>è² é›»</span>ã€‚"; } } document.getElementById('guide-action').innerHTML = actionText; }
function drawSplitBackgroundAndUI() { let rodRight = rod.x + rod.w; let sphereLeft = sphere.x - sphere.r; let dist = sphereLeft - rodRight; let isInduction = dist <= 100; let leftColor = "#f0f3f4"; let rightColor = "#f0f3f4"; let leftLabel = "è¿‘ç«¯ä¸­æ€§"; let rightLabel = "é ç«¯ä¸­æ€§"; let leftLabelColor = "#7f8c8d"; let rightLabelColor = "#7f8c8d"; if (isInduction) { if (rodType === 'glass') { leftColor = "rgba(235, 245, 251, 1)"; rightColor = "rgba(253, 237, 236, 1)"; leftLabel = "å¸¶è² é›» (-)"; rightLabel = "å¸¶æ­£é›» (+)"; leftLabelColor = "#2980b9"; rightLabelColor = "#c0392b"; } else { leftColor = "rgba(253, 237, 236, 1)"; rightColor = "rgba(235, 245, 251, 1)"; leftLabel = "å¸¶æ­£é›» (+)"; rightLabel = "å¸¶è² é›» (-)"; leftLabelColor = "#c0392b"; rightLabelColor = "#2980b9"; } } ctx.fillStyle = leftColor; ctx.fillRect(0, 0, sphere.x, canvas.height); ctx.fillStyle = rightColor; ctx.fillRect(sphere.x, 0, canvas.width - sphere.x, canvas.height); ctx.save(); ctx.beginPath(); ctx.moveTo(sphere.x, 0); ctx.lineTo(sphere.x, canvas.height); ctx.lineWidth = 3; ctx.strokeStyle = "#95a5a6"; ctx.setLineDash([15, 10]); ctx.stroke(); ctx.restore(); const uiY = 50; const boxW = 160; const boxH = 50; let boxBorderColor = isInduction ? "#27ae60" : "#f39c12"; let boxTextColor = isInduction ? "#27ae60" : "#e67e22"; ctx.save(); ctx.fillStyle = "#fff"; ctx.strokeStyle = boxBorderColor; ctx.lineWidth = 4; roundRect(ctx, sphere.x - 90, 20, 180, 40, 20, true, true); ctx.fillStyle = boxTextColor; ctx.font = "bold 18px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText("ç¸½é›»é‡ï¼š0 (ä¸­æ€§)", sphere.x, 46); ctx.restore(); ctx.save(); ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 2; roundRect(ctx, sphere.x - 120 - boxW, uiY + 50, boxW, boxH, 10, true, true); ctx.beginPath(); ctx.moveTo(sphere.x - 120 - boxW/2, uiY + 50 + boxH); ctx.lineTo(sphere.x - sphere.r/2, sphere.y - sphere.r/2); ctx.strokeStyle = "#999"; ctx.lineWidth = 3; ctx.stroke(); ctx.fillStyle = leftLabelColor; ctx.font = "bold 22px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText(leftLabel, sphere.x - 120 - boxW/2, uiY + 83); ctx.restore(); ctx.save(); ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 2; roundRect(ctx, sphere.x + 120, uiY + 50, boxW, boxH, 10, true, true); ctx.beginPath(); ctx.moveTo(sphere.x + 120 + boxW/2, uiY + 50 + boxH); ctx.lineTo(sphere.x + sphere.r/2, sphere.y - sphere.r/2); ctx.strokeStyle = "#999"; ctx.lineWidth = 3; ctx.stroke(); ctx.fillStyle = rightLabelColor; ctx.font = "bold 22px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText(rightLabel, sphere.x + 120 + boxW/2, uiY + 83); ctx.restore(); }
function update() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawSplitBackgroundAndUI(); let rodRight = rod.x + rod.w; let sphereLeft = sphere.x - sphere.r; let dist = sphereLeft - rodRight; let isInduction = dist <= 100; ctx.fillStyle = '#7f8c8d'; ctx.fillRect(sphere.x - 5, sphere.y + sphere.r, 10, 100); ctx.fillStyle = '#95a5a6'; ctx.fillRect(sphere.x - 30, sphere.y + sphere.r + 100, 60, 10); ctx.beginPath(); ctx.arc(sphere.x, sphere.y, sphere.r, 0, Math.PI*2); let gradSphere = ctx.createRadialGradient(sphere.x-30, sphere.y-30, 10, sphere.x, sphere.y, sphere.r); gradSphere.addColorStop(0, '#f1c40f'); gradSphere.addColorStop(1, '#f39c12'); ctx.fillStyle = gradSphere; ctx.fill(); ctx.lineWidth = 5; ctx.strokeStyle = isInduction ? '#2ecc71' : '#e67e22'; ctx.stroke(); drawLabel(ctx, "é‡‘å±¬çƒ (å°é«”)", sphere.x, sphere.y + sphere.r + 135, 0); ctx.save(); let gradRod = ctx.createLinearGradient(rod.x, 0, rod.x + rod.w, 0); if (rodType === 'glass') { gradRod.addColorStop(0, 'rgba(230, 245, 255, 0.9)'); gradRod.addColorStop(1, 'rgba(200, 230, 255, 0.9)'); } else { gradRod.addColorStop(0, '#7f8c8d'); gradRod.addColorStop(1, '#2c3e50'); } ctx.fillStyle = gradRod; ctx.strokeStyle = '#999'; ctx.lineWidth = 2; roundRect(ctx, rod.x, rod.y, rod.w, rod.h, 15, true, true); let rodChargeType = (rodType === 'glass') ? 1 : -1; drawLabel(ctx, rod.name, rod.x + rod.w/2, rod.y - 30, rodChargeType); ctx.restore(); particles.filter(p => p.charge > 0).forEach(p => { p.update(); p.draw(); }); particles.filter(p => p.charge < 0).forEach(p => { p.update(); p.draw(); }); updateGuide(); if (rod.draggable && mousePos.x > rod.x && mousePos.x < rod.x+rod.w && mousePos.y > rod.y && mousePos.y < rod.y+rod.h) { canvas.style.cursor = 'pointer'; } else { canvas.style.cursor = 'default'; } requestAnimationFrame(update); }
var mousePos = {x:0, y:0};
canvas.addEventListener('mousedown', (e) => { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; if (mx > rod.x && mx < rod.x + rod.w && my > rod.y && my < rod.y + rod.h) { draggingObj = rod; dragOffset.x = mx - rod.x; dragOffset.y = my - rod.y; } });
canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; mousePos.x = mx; mousePos.y = my; if (!draggingObj) return; let newX = mx - dragOffset.x; let newY = my - dragOffset.y; let rodRight = newX + rod.w; let sphereLeft = sphere.x - sphere.r; let maxRodX = sphereLeft - MIN_GAP - rod.w; if (newX > maxRodX) { newX = maxRodX; } if (newX < 0) newX = 0; if (newY < 0) newY = 0; if (newY > canvas.height - rod.h) newY = canvas.height - rod.h; rod.x = newX; rod.y = newY; });
window.addEventListener('mouseup', () => { draggingObj = null; });

// --- iPad Touch Event Support ---
canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length > 1) return;
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousedown', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousemove', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    var mouseEvent = new MouseEvent('mouseup', {
        bubbles: true, cancelable: true, view: window
    });
    window.dispatchEvent(mouseEvent);
}, {passive: false});

resizeCanvas();
init(); update();
</script>
</body>
</html>
    </textarea>

    <!-- å¯¦é©— 3ï¼šæ„Ÿæ‡‰èµ·é›» (iPad å„ªåŒ–ç‰ˆ) -->
    <textarea id="code-exp-3" class="source-code-storage">
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å¯¦é©— 3ï¼šæ„Ÿæ‡‰èµ·é›» (iPadç‰ˆ)</title>
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; background-color: #ecf0f1; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; -webkit-user-select: none; }
        #main-layout { display: flex; gap: 20px; padding: 20px; background-color: #fff; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 1350px; width: 98%; height: 90vh; box-sizing: border-box; }
        #left-panel { flex: 0 0 70%; display: flex; flex-direction: column; gap: 15px; height: 100%; }
        #ui-container { display: flex; gap: 10px; height: 50px; align-items: center; flex-shrink: 0; }
        #canvas-wrapper { position: relative; border-radius: 10px; overflow: hidden; border: 2px solid #bdc3c7; background-color: #f9f9f9; flex: 1; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        #right-panel { flex: 1; display: flex; flex-direction: column; background-color: #fdfefe; border-left: 2px solid #eee; padding-left: 20px; min-width: 250px; overflow-y: auto; }
        .guide-box { background-color: #fcf3cf; border-left: 5px solid #f1c40f; padding: 15px; border-radius: 5px; margin-bottom: 20px; transition: all 0.3s; }
        .guide-title { font-size: 1.2rem; font-weight: bold; color: #d35400; margin-bottom: 10px; display: flex; align-items: center; gap: 5px; }
        .guide-content { font-size: 1rem; line-height: 1.6; color: #34495e; }
        .status-box { background-color: #fff8e1; border: 1px solid #ffe0b2; padding: 15px; border-radius: 8px; margin-top: auto; }
        button { padding: 10px 20px; font-size: 1rem; border: none; border-radius: 8px; cursor: pointer; background-color: #3498db; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s; white-space: nowrap; touch-action: manipulation; }
        button:hover { background-color: #2980b9; transform: translateY(-1px); }
        button.active { background-color: #2c3e50; border: 2px solid #34495e; }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        #next-step-btn { background-color: #e67e22; font-weight: bold; display: none; border: 2px solid #d35400; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        .pos-text { color: #e74c3c; font-weight: bold; }
        .neg-text { color: #3498db; font-weight: bold; }
    </style>
</head>
<body>
<div id="main-layout">
    <div id="left-panel">
        <div id="ui-container">
            <button id="btn-glass" class="mat-btn active" onclick="setRodType('glass')">1. æ­£é›»ç»ç’ƒæ£’ (+)</button>
            <button id="btn-plastic" class="mat-btn" onclick="setRodType('plastic')">2. è² é›»å¡‘è† æ£’ (-)</button>
            <button id="next-step-btn" onclick="goToStep2()">é€²å…¥ä¸‹ä¸€æ­¥ï¼šæ¥åœ°</button>
            <button id="btn-reset" onclick="resetExperiment()" style="background-color:#95a5a6; margin-left:auto;">é‡ç½®å¯¦é©—</button>
        </div>
        <div id="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>
    <div id="right-panel">
        <div class="guide-box" id="guide-box">
            <div class="guide-title" id="guide-title">æ­¥é©Ÿ 1ï¼šé è¿‘æ„Ÿæ‡‰</div>
            <div class="guide-content" id="guide-content">è«‹æ‹–æ›³å¸¶é›»æ£’<b>é è¿‘</b>é‡‘å±¬çƒå·¦å´ã€‚<br>è§€å¯Ÿé›»è·åˆ†é›¢ç¾è±¡ã€‚</div>
        </div>
        <div class="status-box">
            <div style="font-weight:bold; color:#7f8c8d; margin-bottom:5px;">é‡‘å±¬çƒç‹€æ…‹</div>
            <div id="net-charge-display" style="font-size:1.4rem; font-weight:bold; color:#27ae60;">0 (ä¸­æ€§)</div>
        </div>
    </div>
</div>
<script>
var canvas, ctx; var currentStep = 1; var rodType = 'glass'; var draggingObj = null; var dragOffset = {x: 0, y: 0}; var mousePos = {x:0, y:0}; var flowTimer = 0; 
var rod = { x: 10, y: 200, w: 200, h: 40, name: 'ç»æ£’', draggable: true }; var sphere = { x: 580, y: 220, r: 90, name: 'é‡‘å±¬çƒ', draggable: false }; var person = { x: 800, y: 400, visible: false, isGrounded: false, draggable: false }; var particles = [];
var PARTICLE_RADIUS = 7; var SPHERE_RADIUS = 90; var GRID_SPACING = 34; var INFLUENCE_DIST = 260; var FLOW_RATE = 4;
class Particle {
    constructor(x, y, charge, parent, isFixed = false) { this.charge = charge; this.parent = parent; this.isFixed = isFixed; this.baseX = x; this.baseY = y; if (parent === 'rod') { this.currentX = rod.x + x; this.currentY = rod.y + y; } else { this.currentX = sphere.x + x; this.currentY = sphere.y + y; } this.isFlowing = false; this.isOutgoing = false; this.pathPoints = []; this.pathIndex = 0; this.targetX = this.currentX; this.targetY = this.currentY; }
    startFlowOut() { this.isFlowing = true; this.isOutgoing = true; this.parent = 'body_transit'; let sphereEdgeX = sphere.x + SPHERE_RADIUS; let sphereEdgeY = sphere.y; this.pathPoints = [ {x: this.currentX, y: this.currentY}, {x: sphereEdgeX, y: sphereEdgeY}, {x: person.x - 20, y: person.y - 125}, {x: person.x, y: person.y - 125}, {x: person.x, y: person.y - 50}, {x: person.x, y: person.y}, {x: person.x, y: person.y + 100} ]; this.pathIndex = 0; }
    startFlowIn(finalTargetX, finalTargetY) { this.isFlowing = true; this.isOutgoing = false; this.parent = 'body_transit'; let sphereEdgeX = sphere.x + SPHERE_RADIUS; let sphereEdgeY = sphere.y; this.currentX = person.x; this.currentY = person.y + 100; this.targetX = finalTargetX; this.targetY = finalTargetY; this.pathPoints = [ {x: person.x, y: person.y + 100}, {x: person.x, y: person.y}, {x: person.x, y: person.y - 50}, {x: person.x, y: person.y - 125}, {x: person.x - 20, y: person.y - 125}, {x: sphereEdgeX, y: sphereEdgeY}, {x: finalTargetX, y: finalTargetY} ]; this.pathIndex = 0; }
    update() { if (this.isFlowing) { if (this.pathIndex < this.pathPoints.length) { let target = this.pathPoints[this.pathIndex]; let dx = target.x - this.currentX; let dy = target.y - this.currentY; let dist = Math.sqrt(dx*dx + dy*dy); let speed = 25; if (dist < speed) { this.currentX = target.x; this.currentY = target.y; this.pathIndex++; if (this.pathIndex >= this.pathPoints.length) { if (this.pathPoints[this.pathPoints.length-1].y > person.y) { this.charge = 0; this.parent = 'ground'; } else { this.isFlowing = false; this.parent = 'sphere'; } } } else { this.currentX += (dx/dist) * speed; this.currentY += (dy/dist) * speed; } } return; } if (this.parent === 'rod') { this.currentX = rod.x + this.baseX; this.currentY = rod.y + this.baseY; } else if (this.parent === 'sphere') { if (this.isFixed) { this.currentX = sphere.x + this.baseX; this.currentY = sphere.y + this.baseY; } else { this.currentX += (this.targetX - this.currentX) * 0.2; this.currentY += (this.targetY - this.currentY) * 0.2; let jitter = 1.0; this.currentX += (Math.random() - 0.5) * jitter; this.currentY += (Math.random() - 0.5) * jitter; } } }
    draw() { if (this.charge === 0) return; ctx.beginPath(); ctx.arc(this.currentX, this.currentY, PARTICLE_RADIUS, 0, Math.PI * 2); ctx.fillStyle = (this.charge > 0) ? '#e74c3c' : '#3498db'; ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.charge > 0 ? '+' : '-', this.currentX, this.currentY + 1); }
}
function calculateElectronTargets() { let sphereElectrons = particles.filter(p => p.parent === 'sphere' && p.charge === -1 && !p.isFlowing && !p.isFixed); let sphereProtons = particles.filter(p => p.parent === 'sphere' && p.charge === 1); let rodCx = rod.x + rod.w / 2; let rodCy = rod.y + rod.h / 2; let distToRod = Math.sqrt((rodCx - sphere.x)**2 + (rodCy - sphere.y)**2) - (rod.w/2 + SPHERE_RADIUS); distToRod = Math.max(0, distToRod); let angleToRod = Math.atan2(rodCy - sphere.y, rodCx - sphere.x); let influence = 0; if (distToRod < INFLUENCE_DIST) { influence = Math.pow(1 - (distToRod / INFLUENCE_DIST), 2); } let rodCharge = (rodType === 'glass') ? 1 : -1; let leftSeats = []; let rightSeats = []; sphereProtons.forEach(p => { let seat = { x: sphere.x + p.baseX, y: sphere.y + p.baseY, filled: false }; if (p.baseX > 0) rightSeats.push(seat); else leftSeats.push(seat); }); leftSeats.sort((a, b) => a.x - b.x); rightSeats.sort((a, b) => a.x - b.x); let availableElectrons = [...sphereElectrons]; let excessElectrons = []; function assignToSeats(seats, applyInduction) { seats.forEach(seat => { if (availableElectrons.length === 0) return; let bestEleIndex = -1; let minDist = Infinity; for(let i=0; i<availableElectrons.length; i++) { let ele = availableElectrons[i]; let d = (ele.currentX - seat.x)**2 + (ele.currentY - seat.y)**2; if (d < minDist) { minDist = d; bestEleIndex = i; } } if (bestEleIndex !== -1) { let ele = availableElectrons[bestEleIndex]; if (applyInduction && influence > 0.01) { let moveDir = (rodCharge === 1) ? 1 : -1; let moveAngle = angleToRod; if (moveDir === -1) moveAngle += Math.PI; let maxShift = 35; let shift = maxShift * influence; ele.targetX = seat.x + Math.cos(moveAngle) * shift; ele.targetY = seat.y + Math.sin(moveAngle) * shift; let dC = Math.sqrt((ele.targetX - sphere.x)**2 + (ele.targetY - sphere.y)**2); if (dC > SPHERE_RADIUS - 6) { let ang = Math.atan2(ele.targetY - sphere.y, ele.targetX - sphere.x); ele.targetX = sphere.x + Math.cos(ang) * (SPHERE_RADIUS - 6); ele.targetY = sphere.y + Math.sin(ang) * (SPHERE_RADIUS - 6); } } else { ele.targetX = seat.x + 5; ele.targetY = seat.y + 5; } seat.filled = true; availableElectrons.splice(bestEleIndex, 1); } }); } if (person.isGrounded) { if (influence < 0.05) { let allSeats = [...leftSeats, ...rightSeats]; allSeats.sort((a,b) => a.x - b.x); assignToSeats(allSeats, false); } else { assignToSeats(rightSeats, false); assignToSeats(leftSeats, true); } } else { if (rodCharge === 1) { assignToSeats(leftSeats, true); assignToSeats(rightSeats, true); } else { if (influence > 0.05) { assignToSeats(rightSeats, true); assignToSeats(leftSeats, true); } else { let allSeats = [...leftSeats, ...rightSeats]; allSeats.sort((a, b) => { let distA = (a.x - sphere.x)**2 + (a.y - sphere.y)**2; let distB = (b.x - sphere.x)**2 + (b.y - sphere.y)**2; return distA - distB; }); assignToSeats(allSeats, false); } } } excessElectrons = availableElectrons; if (excessElectrons.length > 0) { let boundaryR = SPHERE_RADIUS - 5; let totalSurface = excessElectrons.length; excessElectrons.forEach((ele, index) => { if (influence > 0.05) { let targetCenterAngle = angleToRod; if (rodCharge === -1) targetCenterAngle += Math.PI; let spread = (Math.PI / 1.5) * (index / Math.max(1, totalSurface - 1) - 0.5); let finalAngle = targetCenterAngle + spread; ele.targetX = sphere.x + Math.cos(finalAngle) * boundaryR; ele.targetY = sphere.y + Math.sin(finalAngle) * boundaryR; } else { let angleStep = (Math.PI * 2) / totalSurface; let angle = index * angleStep; ele.targetX = sphere.x + Math.cos(angle) * boundaryR; ele.targetY = sphere.y + Math.sin(angle) * boundaryR; } }); } }
function init() { 
    canvas = document.getElementById('simCanvas'); ctx = canvas.getContext('2d'); 
    resizeCanvas();
    person.y = canvas.height - 130; 
    setRodType('glass'); 
    canvas.addEventListener('mousedown', onMouseDown); 
    canvas.addEventListener('mousemove', onMouseMove); 
    window.addEventListener('mouseup', onMouseUp); 
    requestAnimationFrame(update); 
}
function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    // é‡æ–°ç½®ä¸­
    sphere.x = canvas.width * 0.6;
    sphere.y = canvas.height * 0.45;
    person.x = canvas.width * 0.85;
    person.y = canvas.height - 130;
}
window.addEventListener('resize', resizeCanvas);

function setRodType(type) { if(currentStep > 1 && currentStep < 4) return; rodType = type; particles = []; document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active')); document.getElementById(type === 'glass' ? 'btn-glass' : 'btn-plastic').classList.add('active'); rod.name = (type === 'glass') ? 'ç»æ£’' : 'å¡‘è† æ£’'; let rodChargeType = (type === 'glass') ? 1 : -1; let chargeCount = 10; let spacing = (rod.w - 40) / (chargeCount - 1); for(let i=0; i<chargeCount; i++) { let rx = 20 + i * spacing; let ry = rod.h / 2; particles.push(new Particle(rx, ry, rodChargeType, 'rod')); } let checkRadius = SPHERE_RADIUS - 10; for(let y = -SPHERE_RADIUS; y <= SPHERE_RADIUS; y += GRID_SPACING) { for(let x = -SPHERE_RADIUS; x <= SPHERE_RADIUS; x += GRID_SPACING) { if (Math.sqrt(x*x + y*y) < checkRadius) { particles.push(new Particle(x, y, 1, 'sphere', true)); particles.push(new Particle(x, y, -1, 'sphere', false)); } } } updateGuide(); }
function resetExperiment() { currentStep = 1; rod.draggable = true; rod.x = 10; rod.y = 200; person.visible = false; person.draggable = false; person.x = canvas.width * 0.85; person.isGrounded = false; document.getElementById('next-step-btn').style.display = 'none'; document.querySelectorAll('.mat-btn').forEach(b => b.disabled = false); setRodType(rodType); updateGuide(); }
function goToStep2() { if (currentStep === 1) { currentStep = 2; rod.draggable = false; person.visible = true; person.draggable = true; person.x = canvas.width * 0.85; updateGuide(); document.getElementById('next-step-btn').style.display = 'none'; } }
function manageGroundFlow() { if (!person.isGrounded) return; flowTimer++; if (flowTimer < FLOW_RATE) return; flowTimer = 0; let electronsOnSphere = particles.filter(p => p.parent === 'sphere' && p.charge === -1).length; let incomingElectrons = particles.filter(p => p.parent === 'body_transit' && p.charge === -1 && !p.isOutgoing).length; let currentEffectiveCount = electronsOnSphere + incomingElectrons; let protons = particles.filter(p => p.parent === 'sphere' && p.charge === 1); let protonCount = protons.length; let rodCx = rod.x + rod.w/2; let rodCy = rod.y + rod.h/2; let distToRod = Math.sqrt((rodCx - sphere.x)**2 + (rodCy - sphere.y)**2) - (rod.w/2 + SPHERE_RADIUS); distToRod = Math.max(0, distToRod); let influenceFactor = 0; if (distToRod < INFLUENCE_DIST) { influenceFactor = 1 - (distToRod / INFLUENCE_DIST); } let targetElectronCount = protonCount; let maxInduction = Math.floor(protonCount * 0.6); if (rodType === 'glass') { targetElectronCount = protonCount + Math.floor(maxInduction * influenceFactor); } else { targetElectronCount = protonCount - Math.floor(maxInduction * influenceFactor); } let isNeutralizing = (influenceFactor < 0.05); if (isNeutralizing) { targetElectronCount = protonCount; } let diff = targetElectronCount - currentEffectiveCount; if (!isNeutralizing && Math.abs(diff) <= 1) return; if (isNeutralizing && diff === 0) return; if (diff > 0) { let p = new Particle(0, 0, -1, 'body_transit', false); p.startFlowIn(sphere.x + 40, sphere.y); particles.push(p); } else if (diff < 0) { let electrons = particles.filter(p => p.parent === 'sphere' && p.charge === -1 && !p.isFlowing); electrons.sort((a, b) => { let dA = (a.currentX - sphere.x)**2 + (a.currentY - sphere.y)**2; let dB = (b.currentX - sphere.x)**2 + (b.currentY - sphere.y)**2; return dB - dA; }); let p = electrons[0]; if (p) p.startFlowOut(); } }
function checkGrounding() { if (!person.visible) return; let handX = person.x - 30; let touchDist = (sphere.x + SPHERE_RADIUS) - handX; person.isGrounded = (Math.abs(touchDist) < 65); if (person.isGrounded) { manageGroundFlow(); } if (currentStep === 2) { if (!person.isGrounded) { let net = getNetCharge(); if (net !== 0) { currentStep = 3; rod.draggable = true; person.draggable = false; person.visible = false; person.x = 900; updateGuide(); } } } }
function getNetCharge() { let net = 0; particles.forEach(p => { if (p.parent === 'sphere' && p.charge !== 0) net += p.charge; }); return net; }
function updateUI() { let net = getNetCharge(); let el = document.getElementById('net-charge-display'); if (net > 0) { el.innerHTML = `+${net} <span style='font-size:0.8rem'>(å¸¶æ­£é›»)</span>`; el.style.color = '#e74c3c'; } else if (net < 0) { el.innerHTML = `${net} <span style='font-size:0.8rem'>(å¸¶è² é›»)</span>`; el.style.color = '#3498db'; } else { el.innerHTML = `0 <span style='font-size:0.8rem'>(ä¸­æ€§)</span>`; el.style.color = '#27ae60'; } particles = particles.filter(p => !(p.parent === 'ground' && p.charge === 0)); }
function updateGuide() { const title = document.getElementById('guide-title'); const content = document.getElementById('guide-content'); const box = document.getElementById('guide-box'); const nextBtn = document.getElementById('next-step-btn'); let rodCx = rod.x + rod.w/2; let rodCy = rod.y + rod.h/2; let distToRod = Math.sqrt((rodCx - sphere.x)**2 + (rodCy - sphere.y)**2) - (rod.w/2 + SPHERE_RADIUS); let isInduction = distToRod <= INFLUENCE_DIST; if (currentStep === 1) { title.innerText = "æ­¥é©Ÿ 1ï¼šé è¿‘æ„Ÿæ‡‰"; content.innerHTML = "è«‹æ‹–æ›³å¸¶é›»æ£’<b>é è¿‘</b>é‡‘å±¬çƒã€‚<br>å˜—è©¦ä¸Šä¸‹ç§»å‹•ï¼Œè§€å¯Ÿé›»è·å¦‚ä½•éš¨æ£’å­ä½ç½®ç§»å‹•ã€‚"; box.style.borderLeftColor = "#f1c40f"; box.style.backgroundColor = "#fcf3cf"; if (isInduction) nextBtn.style.display = 'block'; else nextBtn.style.display = 'none'; } else if (currentStep === 2) { title.innerText = "æ­¥é©Ÿ 2ï¼šæ¥åœ°èˆ‡æ–·é–‹"; content.innerHTML = "1. æ‹–æ›³å°äºº<b>æ¥è§¸</b>é‡‘å±¬çƒ(æ¥åœ°)ã€‚<br>2. è§€å¯Ÿå³å´é›»è·å¿…ç‚ºä¸­æ€§(æˆ–è¢«æ’æ–¥å…¥åœ°)ã€‚<br>3. ç©©å®šå¾Œï¼Œæ‹–æ›³å°äºº<b>é é›¢</b>(æ–·åœ°)ã€‚"; box.style.borderLeftColor = "#3498db"; box.style.backgroundColor = "#ebf5fb"; } else if (currentStep === 3) { title.innerText = "æ­¥é©Ÿ 3ï¼šç§»é–‹æ£’å­"; content.innerHTML = "æ¥åœ°ç·šå·²æ–·é–‹ï¼é›»è·è¢«é–åœ¨çƒä¸Šã€‚<br>ç¾åœ¨è«‹<b>æ‹–æ›³æ£’å­é é›¢</b>é‡‘å±¬çƒã€‚<br>è§€å¯Ÿé›»è·æœ€å¾Œçš„åˆ†ä½ˆ(ç›¸æ–¥è‡³è¡¨é¢)ã€‚"; box.style.borderLeftColor = "#e67e22"; box.style.backgroundColor = "#fbeee6"; let net = getNetCharge(); if (distToRod > 270 && net !== 0) { currentStep = 4; updateGuide(); } } else if (currentStep === 4) { title.innerText = "çµè«–èˆ‡è‡ªç”±æ“ä½œ"; let net = getNetCharge(); let result = (net > 0) ? "å¸¶æ­£é›»" : "å¸¶è² é›»"; let colorClass = (net > 0) ? "pos-text" : "neg-text"; content.innerHTML = `å¯¦é©—çµæœï¼šé‡‘å±¬çƒ<span class='${colorClass}'>${result}</span>ã€‚<br>å¤šé¤˜é›»è·å› ç›¸æ–¥åˆ†ä½ˆæ–¼<b>å°é«”è¡¨é¢</b>ã€‚<br><br><b>è‡ªç”±å¯¦é©—ï¼š</b><br>1. ç§»é–‹æ£’å­ä¸¦æ¥åœ° -> æ¢å¾©ä¸­æ€§<br>2. å†æ¬¡é è¿‘æ£’å­ä¸¦æ¥åœ° -> é‡æ–°èµ·é›»`; box.style.borderLeftColor = "#2ecc71"; box.style.backgroundColor = "#e8f8f5"; person.visible = true; person.draggable = true; rod.draggable = true; } }
function drawSplitBackgroundAndUI() { let rodCx = rod.x + rod.w/2; let rodCy = rod.y + rod.h/2; let distToRod = Math.sqrt((rodCx - sphere.x)**2 + (rodCy - sphere.y)**2) - (rod.w/2 + SPHERE_RADIUS); let uiShowInduction = (distToRod <= INFLUENCE_DIST) && (Math.pow(1 - (distToRod / INFLUENCE_DIST), 2) > 0.05); let net = getNetCharge(); let leftColor = "#f0f3f4"; let rightColor = "#f0f3f4"; let leftLabel = ""; let rightLabel = ""; let leftLabelColor = "#7f8c8d"; let rightLabelColor = "#7f8c8d"; if (!uiShowInduction && net === 0) { leftLabel = "ä¸­æ€§"; rightLabel = "ä¸­æ€§"; } else if (!uiShowInduction && net !== 0) { let txt = (net > 0) ? "å¸¶æ­£é›» (+)" : "å¸¶è² é›» (-)"; let col = (net > 0) ? "rgba(253, 237, 236, 0.5)" : "rgba(235, 245, 251, 0.5)"; let txtCol = (net > 0) ? "#c0392b" : "#2980b9"; leftColor = rightColor = col; leftLabel = rightLabel = txt; leftLabelColor = rightLabelColor = txtCol; } else if (uiShowInduction) { if (rodType === 'glass') { leftColor = "rgba(235, 245, 251, 0.8)"; leftLabel = "æ„Ÿæ‡‰å¸¶è² é›» (-)"; leftLabelColor = "#2980b9"; if (person.isGrounded) { rightColor = "#ecf0f1"; rightLabel = "æ¥åœ° (å¼·åˆ¶ä¸­æ€§)"; rightLabelColor = "#7f8c8d"; } else { if (net === 0) { rightColor = "rgba(253, 237, 236, 0.8)"; rightLabel = "æ„Ÿæ‡‰å¸¶æ­£é›» (+)"; rightLabelColor = "#c0392b"; } else { rightLabel = "é›»è·åˆ†ä½ˆ"; } } } else { leftColor = "rgba(253, 237, 236, 0.8)"; leftLabel = "æ„Ÿæ‡‰å¸¶æ­£é›» (+)"; leftLabelColor = "#c0392b"; if (person.isGrounded) { rightColor = "#ecf0f1"; rightLabel = "æ¥åœ° (å¼·åˆ¶ä¸­æ€§)"; rightLabelColor = "#7f8c8d"; } else { if (net === 0) { rightColor = "rgba(235, 245, 251, 0.8)"; rightLabel = "æ„Ÿæ‡‰å¸¶è² é›» (-)"; rightLabelColor = "#2980b9"; } else { rightLabel = "é›»è·åˆ†ä½ˆ"; } } } } ctx.fillStyle = leftColor; ctx.fillRect(0, 0, sphere.x, canvas.height); ctx.fillStyle = rightColor; ctx.fillRect(sphere.x, 0, canvas.width - sphere.x, canvas.height); ctx.save(); ctx.beginPath(); ctx.moveTo(sphere.x, 0); ctx.lineTo(sphere.x, canvas.height); ctx.lineWidth = 3; ctx.strokeStyle = "#95a5a6"; ctx.setLineDash([15, 10]); ctx.stroke(); ctx.restore(); const uiY = 30; const boxW = 180; const boxH = 45; if (leftLabel) { ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.strokeStyle="#bdc3c7"; ctx.lineWidth=2; roundRect(ctx, sphere.x - 140 - boxW, uiY, boxW, boxH, 10, true, true); ctx.fillStyle = leftLabelColor; ctx.font = "bold 18px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText(leftLabel, sphere.x - 140 - boxW/2, uiY + 28); ctx.restore(); } if (rightLabel) { ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.strokeStyle="#bdc3c7"; ctx.lineWidth=2; roundRect(ctx, sphere.x + 140, uiY, boxW, boxH, 10, true, true); ctx.fillStyle = rightLabelColor; ctx.font = "bold 18px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText(rightLabel, sphere.x + 140 + boxW/2, uiY + 28); ctx.restore(); } }
function drawPerson() { if (!person.visible) return; let x = person.x; let y = person.y; ctx.save(); ctx.strokeStyle = "#34495e"; ctx.lineWidth = 5; ctx.lineCap = "round"; let headY = y - 130; let bodyTopY = headY + 25; let crotchY = y - 50; ctx.beginPath(); ctx.moveTo(x, crotchY); ctx.lineTo(x - 20, y); ctx.moveTo(x, crotchY); ctx.lineTo(x + 20, y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x, bodyTopY); ctx.lineTo(x, crotchY); ctx.stroke(); ctx.fillStyle = "#f1c40f"; ctx.beginPath(); ctx.arc(x, headY, 25, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(x-8, headY-5, 3, 0, Math.PI*2); ctx.fillStyle="black"; ctx.fill(); ctx.beginPath(); ctx.arc(x+8, headY-5, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x, headY+8, 10, 0, Math.PI); ctx.stroke(); let shoulderY = bodyTopY + 10; ctx.beginPath(); ctx.moveTo(x, shoulderY); if (person.isGrounded) { ctx.lineTo(sphere.x + SPHERE_RADIUS, sphere.y); } else { ctx.lineTo(x - 40, shoulderY + 30); } ctx.stroke(); ctx.beginPath(); ctx.moveTo(x, shoulderY); ctx.lineTo(x + 20, shoulderY + 40); ctx.stroke(); if (person.isGrounded) { let gx = x; let gy = y + 5; ctx.strokeStyle = "#27ae60"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(gx, gy); ctx.lineTo(gx, gy + 15); ctx.moveTo(gx - 20, gy + 15); ctx.lineTo(gx + 20, gy + 15); ctx.moveTo(gx - 14, gy + 22); ctx.lineTo(gx + 14, gy + 22); ctx.moveTo(gx - 7, gy + 29); ctx.lineTo(gx + 7, gy + 29); ctx.stroke(); ctx.fillStyle = "#27ae60"; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.fillText("æ¥åœ°", gx, gy + 50); } if(person.draggable && !person.isGrounded) { ctx.fillStyle = "#e67e22"; ctx.font = "14px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText("æ‹–æ›³æˆ‘æ¥åœ°", x, headY - 35); } else if (person.draggable && person.isGrounded) { ctx.fillStyle = "#e67e22"; ctx.font = "14px Microsoft JhengHei"; ctx.textAlign = "center"; ctx.fillText("æ‹–æ›³é›¢é–‹(æ–·é›»)", x, headY - 35); } ctx.restore(); }
function roundRect(ctx, x, y, width, height, radius, fill, stroke) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); if (stroke) ctx.stroke(); if (fill) ctx.fill(); }
function update() { ctx.clearRect(0, 0, canvas.width, canvas.height); calculateElectronTargets(); if (person.visible) checkGrounding(); drawSplitBackgroundAndUI(); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(sphere.x - 5, sphere.y + sphere.r, 10, 150); ctx.fillStyle = '#95a5a6'; ctx.fillRect(sphere.x - 30, sphere.y + sphere.r + 150, 60, 10); drawPerson(); ctx.beginPath(); ctx.arc(sphere.x, sphere.y, sphere.r, 0, Math.PI*2); let gradSphere = ctx.createRadialGradient(sphere.x-30, sphere.y-30, 10, sphere.x, sphere.y, sphere.r); gradSphere.addColorStop(0, '#f1c40f'); gradSphere.addColorStop(1, '#f39c12'); ctx.fillStyle = gradSphere; ctx.fill(); ctx.lineWidth = 3; ctx.strokeStyle = '#e67e22'; ctx.stroke(); ctx.fillStyle = '#555'; ctx.font = 'bold 20px Microsoft JhengHei'; ctx.textAlign = 'center'; ctx.fillText("é‡‘å±¬çƒ (å°é«”)", sphere.x, sphere.y + sphere.r + 180); ctx.save(); let gradRod = ctx.createLinearGradient(rod.x, 0, rod.x + rod.w, 0); if (rodType === 'glass') { gradRod.addColorStop(0, 'rgba(230, 245, 255, 0.9)'); gradRod.addColorStop(1, 'rgba(200, 230, 255, 0.9)'); } else { gradRod.addColorStop(0, '#555'); gradRod.addColorStop(1, '#333'); } ctx.fillStyle = gradRod; ctx.strokeStyle = '#999'; ctx.lineWidth = 2; roundRect(ctx, rod.x, rod.y, rod.w, rod.h, 15, true, true); ctx.fillStyle = '#555'; ctx.font = "16px Microsoft JhengHei"; ctx.fillText(rod.name, rod.x + rod.w/2, rod.y - 10); ctx.restore(); particles.forEach(p => { p.update(); p.draw(); }); updateUI(); updateGuide(); if ( (rod.draggable && mousePos.x > rod.x && mousePos.x < rod.x+rod.w && mousePos.y > rod.y && mousePos.y < rod.y+rod.h) || (person.draggable && person.visible && Math.abs(mousePos.x - person.x) < 50 && mousePos.y > person.y - 150) ) { canvas.style.cursor = 'pointer'; } else { canvas.style.cursor = 'default'; } requestAnimationFrame(update); }
function onMouseDown(e) { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; if (person.visible && person.draggable && mx > person.x - 40 && mx < person.x + 40 && my > person.y - 150 && my < person.y) { draggingObj = person; dragOffset.x = mx - person.x; return; } if (rod.draggable && mx > rod.x && mx < rod.x + rod.w && my > rod.y && my < rod.y + rod.h) { draggingObj = rod; dragOffset.x = mx - rod.x; dragOffset.y = my - rod.y; } }
function onMouseMove(e) { const rect = canvas.getBoundingClientRect(); mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top; if (!draggingObj) return; if (draggingObj === person) { let newX = mousePos.x - dragOffset.x; if (newX < sphere.x + SPHERE_RADIUS + 40) newX = sphere.x + SPHERE_RADIUS + 40; if (newX > canvas.width - 40) newX = canvas.width - 40; person.x = newX; } else if (draggingObj === rod) { let newX = mousePos.x - dragOffset.x; let newY = mousePos.y - dragOffset.y; if (newX + rod.w > sphere.x - 5) { newX = sphere.x - rod.w - 5; } let rodCx = newX + rod.w/2; let rodCy = newY + rod.h/2; let dx = rodCx - sphere.x; let dy = rodCy - sphere.y; let dist = Math.sqrt(dx*dx + dy*dy); let minDist = SPHERE_RADIUS + rod.w/2 + 10; if (dist < minDist) { let angle = Math.atan2(dy, dx); newX = sphere.x + Math.cos(angle) * minDist - rod.w/2; newY = sphere.y + Math.sin(angle) * minDist - rod.h/2; if (newX + rod.w > sphere.x - 5) { newX = sphere.x - rod.w - 5; } } rod.x = newX; rod.y = newY; } }
function onMouseUp() { draggingObj = null; }
window.onload = function() { init(); };

// --- iPad Touch Event Support ---
canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length > 1) return;
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousedown', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousemove', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    var mouseEvent = new MouseEvent('mouseup', {
        bubbles: true, cancelable: true, view: window
    });
    window.dispatchEvent(mouseEvent);
}, {passive: false});

</script>
</body>
</html>
    </textarea>

    <!-- å¯¦é©— 4ï¼šæ¥è§¸èµ·é›» (iPad å„ªåŒ–ç‰ˆ) -->
    <textarea id="code-exp-4" class="source-code-storage">
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å¯¦é©— 2ï¼šæ¥è§¸èµ·é›» (iPadç‰ˆ)</title>
    <style>
        body { margin: 0; padding: 0; font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; background-color: #ecf0f1; min-height: 100vh; display: flex; justify-content: center; align-items: center; overflow: auto; user-select: none; -webkit-user-select: none; }
        #main-layout { display: flex; gap: 12px; padding: 15px; background-color: #fff; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.08); max-width: 1200px; width: 95%; min-width: 0; height: 90vh; box-sizing: border-box; }
        #left-panel { flex: 0 0 70%; display: flex; flex-direction: column; gap: 8px; height: 100%; }
        #ui-container { display: flex; gap: 10px; height: 36px; align-items: center; flex-shrink: 0; }
        #canvas-wrapper { position: relative; border-radius: 8px; overflow: hidden; border: 2px solid #bdc3c7; background-color: #f9f9f9; flex: 1; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        #right-panel { flex: 1; display: flex; flex-direction: column; background-color: #fdfefe; border-left: 2px solid #eee; padding-left: 15px; padding-right: 5px; min-width: 200px; overflow-y: auto; }
        .guide-box { background-color: #fcf3cf; border-left: 5px solid #f1c40f; padding: 12px; border-radius: 5px; margin-bottom: 12px; transition: all 0.3s; }
        .guide-title { font-size: 1.1rem; font-weight: bold; color: #d35400; margin-bottom: 8px; }
        .guide-content { font-size: 0.95rem; line-height: 1.5; color: #34495e; }
        .status-box { background-color: #e8f8f5; border: 1px solid #a2d9ce; padding: 12px; border-radius: 8px; margin-top: auto; }
        button { padding: 8px 16px; font-size: 0.95rem; border: none; border-radius: 5px; cursor: pointer; background-color: #3498db; color: white; box-shadow: 0 2px 3px rgba(0,0,0,0.1); transition: all 0.2s; white-space: nowrap; touch-action: manipulation; }
        button:hover { background-color: #2980b9; transform: translateY(-1px); }
        button.active { background-color: #2c3e50; border: 2px solid #34495e; }
    </style>
</head>
<body>
<div id="main-layout">
    <div id="left-panel">
        <div id="ui-container">
            <button id="btn-plastic" class="mat-btn active" onclick="setRodType('plastic')">1. è² é›»é‡‘å±¬æ£’ (-)</button>
            <button id="btn-glass" class="mat-btn" onclick="setRodType('glass')">2. æ­£é›»é‡‘å±¬æ£’ (+)</button>
            <button id="btn-reset" onclick="resetExperiment()" style="background-color:#95a5a6; margin-left:auto;">é‡ç½®å¯¦é©—</button>
        </div>
        <div id="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>
    <div id="right-panel">
        <div class="guide-box" id="guide-box">
            <div class="guide-title" id="guide-title">æ­¥é©Ÿ 1ï¼šæº–å‚™æ¥è§¸</div>
            <div class="guide-content" id="guide-content">è«‹æ‹–æ›³å¸¶é›»æ£’<b>æ¥è§¸</b>é‡‘å±¬çƒã€‚<br><br><b>è§€å¯Ÿé‡é»ï¼š</b><br>1. é¡¯ç¤ºæ•¸å­—ä»£è¡¨å³æ™‚é›»è·é‡ã€‚<br>2. æ¥è§¸å¾Œï¼Œé›»è·æœƒæµå‹•ä¸¦é‡æ–°åˆ†é…ã€‚<br>3. åˆ†é–‹å¾Œï¼Œå‰©é¤˜é›»è·æœƒäº’æ–¥ä¸¦åˆ†ä½ˆæ–¼ç‰©é«”è¡¨é¢(æˆ–é‚Šç·£)ã€‚</div>
        </div>
        <div class="status-box">
            <div style="font-weight:bold; color:#16a085; margin-bottom:5px;">å¯¦é©—ç‹€æ…‹</div>
            <div>è«‹è§€å¯Ÿç‰©é«”æ—çš„æ•¸å€¼è®ŠåŒ–èˆ‡é›»è·ç§»å‹•ã€‚</div>
        </div>
    </div>
</div>
<script>
var canvas, ctx; var rodType = 'plastic'; var draggingObj = null; var dragOffset = {x: 0, y: 0}; var mousePos = {x:0, y:0};
var rod = { x: 80, y: 110, w: 220, h: 50, name: 'è² é›»é‡‘å±¬æ£’', draggable: true }; var sphere = { x: 550, y: 110, r: 90, name: 'é‡‘å±¬çƒ', draggable: false }; var particles = [];
var PARTICLE_RADIUS = 8; var SPHERE_RADIUS = 90; var TRANSFER_RATE = 8; var transferTimer = 0; var hasTouched = false; var INDUCTION_DIST = 250; var PAIR_OFFSET_X = 7; var PAIR_OFFSET_Y = 7;
class Particle {
    constructor(x, y, charge, parent, isFixed = false, isNeutralPair = false) { this.charge = charge; this.parent = parent; this.isFixed = isFixed; this.isNeutralPair = isNeutralPair; this.baseX = x; this.baseY = y; if (parent === 'rod') { this.currentX = rod.x + x; this.currentY = rod.y + y; this.baseTargetX = x; this.baseTargetY = y; } else { this.currentX = sphere.x + x; this.currentY = sphere.y + y; this.baseTargetX = x; this.baseTargetY = y; } this.isTransferring = false; this.transferTargetX = 0; this.transferTargetY = 0; }
    update() { if (this.isTransferring) { let dx = this.transferTargetX - this.currentX; let dy = this.transferTargetY - this.currentY; let dist = Math.sqrt(dx*dx + dy*dy); if (dist < 5) { this.isTransferring = false; if (this.parent === 'rod_transit') { this.parent = 'rod'; this.baseX = this.currentX - rod.x; this.baseY = this.currentY - rod.y; this.isNeutralPair = false; } else if (this.parent === 'sphere_transit') { this.parent = 'sphere'; this.baseX = this.currentX - sphere.x; this.baseY = this.currentY - sphere.y; this.isNeutralPair = false; } } else { this.currentX += dx * 0.2; this.currentY += dy * 0.2; } } else { let absTargetX, absTargetY; if (this.parent === 'rod') { absTargetX = rod.x + this.baseTargetX; absTargetY = rod.y + this.baseTargetY; } else { absTargetX = sphere.x + this.baseTargetX; absTargetY = sphere.y + this.baseTargetY; } let dx = absTargetX - this.currentX; let dy = absTargetY - this.currentY; this.currentX += dx * 0.15; this.currentY += dy * 0.15; if (!this.isFixed && Math.abs(dx) < 2) { this.currentX += (Math.random() - 0.5) * 0.5; this.currentY += (Math.random() - 0.5) * 0.5; } } }
    draw() { ctx.beginPath(); ctx.arc(this.currentX, this.currentY, PARTICLE_RADIUS, 0, Math.PI * 2); ctx.fillStyle = (this.charge > 0) ? '#e74c3c' : '#3498db'; ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 11px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.charge > 0 ? '+' : '-', this.currentX, this.currentY + 1); }
}
function calculateSpherePhysics() { let electrons = particles.filter(p => p.parent === 'sphere' && p.charge === -1 && !p.isTransferring); let protons = particles.filter(p => p.parent === 'sphere' && p.charge === 1); let rodCx = rod.x + rod.w / 2; let rodCy = rod.y + rod.h / 2; let dx = rodCx - sphere.x; let dy = rodCy - sphere.y; let distToCenter = Math.sqrt(dx*dx + dy*dy); let surfaceDist = distToCenter - (rod.w/2 + SPHERE_RADIUS); let influence = 0; if (surfaceDist < INDUCTION_DIST) { influence = 1 - Math.max(0, surfaceDist / INDUCTION_DIST); } let rodNet = getNetCharge('rod'); let rodChargeSign = (rodNet < 0) ? -1 : 1; let angleToRod = Math.atan2(dy, dx); let seats = protons.map(p => { return { x: p.baseX, y: p.baseY, distSq: p.baseX**2 + p.baseY**2, filled: false }; }); seats.sort((a, b) => a.distSq - b.distSq); let availableElectrons = [...electrons]; let excessElectrons = []; seats.forEach(seat => { if (availableElectrons.length > 0) { let bestIdx = -1; let minDist = Infinity; for(let i=0; i<availableElectrons.length; i++) { let e = availableElectrons[i]; let d = (e.baseX - seat.x)**2 + (e.baseY - seat.y)**2; if(d < minDist) { minDist = d; bestIdx = i; } } if(bestIdx !== -1) { let ele = availableElectrons[bestIdx]; ele.baseTargetX = seat.x + PAIR_OFFSET_X; ele.baseTargetY = seat.y + PAIR_OFFSET_Y; availableElectrons.splice(bestIdx, 1); seat.filled = true; } } }); excessElectrons = availableElectrons; if (excessElectrons.length > 0) { let surfaceRadius = SPHERE_RADIUS - 6; let count = excessElectrons.length; excessElectrons.sort((a,b) => Math.atan2(a.baseY, a.baseX) - Math.atan2(b.baseY, b.baseX)); excessElectrons.forEach((ele, i) => { let angle = (i / count) * Math.PI * 2; ele.baseTargetX = Math.cos(angle) * surfaceRadius; ele.baseTargetY = Math.sin(angle) * surfaceRadius; }); } if (influence > 0.05 && Math.abs(rodNet) > 0) { let shiftAmount = 35 * influence * influence; let forceAngle = angleToRod; if (rodChargeSign === -1) forceAngle += Math.PI; let shiftX = Math.cos(forceAngle) * shiftAmount; let shiftY = Math.sin(forceAngle) * shiftAmount; electrons.forEach(ele => { let finalX = ele.baseTargetX + shiftX; let finalY = ele.baseTargetY + shiftY; let d = Math.sqrt(finalX*finalX + finalY*finalY); if (d > SPHERE_RADIUS - 5) { let ang = Math.atan2(finalY, finalX); finalX = Math.cos(ang) * (SPHERE_RADIUS - 5); finalY = Math.sin(ang) * (SPHERE_RADIUS - 5); } ele.baseTargetX = finalX; ele.baseTargetY = finalY; }); } }
function calculateRodPhysics() { let rodParticles = particles.filter(p => p.parent === 'rod' && !p.isTransferring); if (rodType === 'plastic') { let excessParticles = rodParticles.filter(p => !p.isNeutralPair); if (excessParticles.length > 0) { let margin = 10; let w = rod.w - 2 * margin; let h = rod.h - 2 * margin; let perimeter = 2 * (w + h); let step = perimeter / excessParticles.length; excessParticles.sort((a,b) => a.baseX - b.baseX); excessParticles.forEach((p, i) => { let pos = i * step; let tx, ty; if (pos < w) { tx = margin + pos; ty = margin; } else if (pos < w + h) { tx = margin + w; ty = margin + (pos - w); } else if (pos < 2 * w + h) { tx = margin + w - (pos - (w + h)); ty = margin + h; } else { tx = margin; ty = margin + h - (pos - (2 * w + h)); } p.baseTargetX = tx; p.baseTargetY = ty; }); } } else if (rodType === 'glass') { let protons = rodParticles.filter(p => p.charge === 1); let electrons = rodParticles.filter(p => p.charge === -1); let availableProtons = [...protons]; let cx = rod.w / 2; let cy = rod.h / 2; availableProtons.sort((a, b) => { let da = (a.baseX - cx)**2 + (a.baseY - cy)**2; let db = (b.baseX - cx)**2 + (b.baseY - cy)**2; return da - db; }); electrons.forEach(ele => { if (availableProtons.length > 0) { let targetProton = availableProtons[0]; ele.baseTargetX = targetProton.baseX + PAIR_OFFSET_X; ele.baseTargetY = targetProton.baseY + PAIR_OFFSET_Y; availableProtons.shift(); } else { ele.baseTargetX = Math.random() * rod.w; ele.baseTargetY = Math.random() * rod.h; } }); } }
function handleContact() { let closestX = Math.max(rod.x, Math.min(sphere.x, rod.x + rod.w)); let closestY = Math.max(rod.y, Math.min(sphere.y, rod.y + rod.h)); let dist = Math.sqrt((sphere.x - closestX)**2 + (sphere.y - closestY)**2); let isTouching = dist <= SPHERE_RADIUS + 5.0; if (isTouching) { hasTouched = true; transferTimer++; if (transferTimer > TRANSFER_RATE) { transferTimer = 0; performTransfer(closestX, closestY); } } else { transferTimer = 0; } }
function performTransfer(contactX, contactY) { let sNet = getNetCharge('sphere'); let rNet = getNetCharge('rod'); let totalNet = sNet + rNet; let targetCharge = Math.round(totalNet / 2); if (rodType === 'plastic') { if (rNet < targetCharge) { let candidates = particles.filter(p => p.parent === 'rod' && p.charge === -1 && !p.isNeutralPair && !p.isTransferring); if (candidates.length > 0) { candidates.sort((a,b) => { let da = (a.currentX - contactX)**2 + (a.currentY - contactY)**2; let db = (b.currentX - contactX)**2 + (b.currentY - contactY)**2; return da - db; }); let p = candidates[0]; p.parent = 'sphere_transit'; p.isTransferring = true; let angle = Math.atan2(contactY - sphere.y, contactX - sphere.x); p.transferTargetX = sphere.x + Math.cos(angle) * (SPHERE_RADIUS - 10); p.transferTargetY = sphere.y + Math.sin(angle) * (SPHERE_RADIUS - 10); } } } else { if (sNet < targetCharge) { let candidates = particles.filter(p => p.parent === 'sphere' && p.charge === -1 && !p.isTransferring); if (candidates.length > 0) { candidates.sort((a,b) => { let da = (a.currentX - contactX)**2 + (a.currentY - contactY)**2; let db = (b.currentX - contactX)**2 + (b.currentY - contactY)**2; return da - db; }); let p = candidates[0]; p.parent = 'rod_transit'; p.isTransferring = true; let dx = rod.x + rod.w/2 - contactX; let dy = rod.y + rod.h/2 - contactY; let len = Math.sqrt(dx*dx + dy*dy); p.transferTargetX = contactX + (dx/len) * 50; p.transferTargetY = contactY + (dy/len) * 50; } } } }
function init() { 
    canvas = document.getElementById('simCanvas'); ctx = canvas.getContext('2d'); 
    resizeCanvas();
    setRodType('plastic'); 
    canvas.addEventListener('mousedown', onMouseDown); 
    canvas.addEventListener('mousemove', onMouseMove); 
    window.addEventListener('mouseup', onMouseUp); 
    requestAnimationFrame(update); 
}
function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    // é‡æ–°ç½®ä¸­
    sphere.x = canvas.width * 0.6;
    sphere.y = canvas.height / 2;
    rod.x = 80;
    rod.y = canvas.height / 2 - 25;
}
window.addEventListener('resize', resizeCanvas);

function setRodType(type) { rodType = type; document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active')); document.getElementById(type === 'glass' ? 'btn-glass' : 'btn-plastic').classList.add('active'); rod.name = (type === 'glass') ? 'æ­£é›»é‡‘å±¬æ£’' : 'è² é›»é‡‘å±¬æ£’'; resetParticles(); updateGuide(); }
function resetParticles() { particles = []; hasTouched = false; rod.x = 80; rod.y = canvas.height / 2 - 25; if (rodType === 'plastic') { let excessCount = 10; let margin = 10; let w = rod.w - 2 * margin; let h = rod.h - 2 * margin; let perimeter = 2 * (w + h); let step = perimeter / excessCount; for(let i=0; i<excessCount; i++) { let pos = i * step; let tx, ty; if (pos < w) { tx = margin + pos; ty = margin; } else if (pos < w + h) { tx = margin + w; ty = margin + (pos - w); } else if (pos < 2 * w + h) { tx = margin + w - (pos - (w + h)); ty = margin + h; } else { tx = margin; ty = margin + h - (pos - (2 * w + h)); } particles.push(new Particle(tx, ty, -1, 'rod', true, false)); } } else { let rows = 2; let cols = 5; let startX = rod.w * 0.15; let stepX = (rod.w * 0.7) / (cols - 1); let startY = rod.h * 0.35; let stepY = rod.h * 0.3; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { let px = startX + c * stepX; let py = startY + r * stepY; particles.push(new Particle(px, py, 1, 'rod', true, false)); } } } let layers = [1, 5, 10]; let radii = [0, 35, 65]; for (let l = 0; l < layers.length; l++) { let count = layers[l]; let r = radii[l]; for (let i = 0; i < count; i++) { let angle = (i / count) * Math.PI * 2; let x = Math.cos(angle) * r; let y = Math.sin(angle) * r; particles.push(new Particle(x, y, 1, 'sphere', true)); particles.push(new Particle(x + PAIR_OFFSET_X, y + PAIR_OFFSET_Y, -1, 'sphere', false)); } } }
function resetExperiment() { setRodType(rodType); }
function getNetCharge(obj) { return particles.reduce((acc, p) => { if (obj === 'rod') { if (p.parent === 'rod' || p.parent === 'rod_transit') return acc + p.charge; } else if (obj === 'sphere') { if (p.parent === 'sphere' || p.parent === 'sphere_transit') return acc + p.charge; } return acc; }, 0); }
function drawLabel(ctx, text, x, y, netCharge) { ctx.save(); ctx.font = "bold 24px Arial"; ctx.textAlign = "center"; if (netCharge > 0) ctx.fillStyle = "#e74c3c"; else if (netCharge < 0) ctx.fillStyle = "#3498db"; else ctx.fillStyle = "#27ae60"; let sign = (netCharge > 0) ? "+" : ""; let displayText = `${text} (${sign}${netCharge})`; ctx.fillText(displayText, x, y); ctx.restore(); }
function updateGuide() { const title = document.getElementById('guide-title'); const content = document.getElementById('guide-content'); const box = document.getElementById('guide-box'); let sNet = getNetCharge('sphere'); let rNet = getNetCharge('rod'); if (!hasTouched && sNet === 0) { title.innerText = "æ­¥é©Ÿ 1ï¼šæº–å‚™æ¥è§¸"; content.innerHTML = `ç›®å‰çš„æ£’å­æ˜¯ <b>${rod.name}</b>ã€‚<br>æ£’å­æ·¨é›»è·ï¼š<b>${rNet > 0 ? '+'+rNet : rNet}</b>ã€‚<br>è«‹æ‹–æ›³æ£’å­ç¢°è§¸é‡‘å±¬çƒã€‚`; box.style.borderLeftColor = "#f1c40f"; box.style.backgroundColor = "#fcf3cf"; } else if (hasTouched) { title.innerText = "å¯¦é©—çµæœï¼šæ¥è§¸èµ·é›»"; content.innerHTML = `é›»è·é‡æ–°åˆ†é…å®Œæˆã€‚<br><b>æ£’å­é›»è·ï¼š${rNet > 0 ? '+'+rNet : rNet}</b><br><b>é‡‘å±¬çƒé›»è·ï¼š${sNet > 0 ? '+'+sNet : sNet}</b><br>å…©è€…å¸¶åŒæ€§é›»ï¼Œä¸”é›»è·å‡å‹»åˆ†ä½ˆã€‚`; box.style.borderLeftColor = "#3498db"; box.style.backgroundColor = "#ebf5fb"; } }
function update() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 1; for(let i=0; i<canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); } for(let i=0; i<canvas.height; i+=40) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); } handleContact(); calculateSpherePhysics(); calculateRodPhysics(); let sNet = getNetCharge('sphere'); let rNet = getNetCharge('rod'); ctx.beginPath(); ctx.arc(sphere.x, sphere.y, sphere.r, 0, Math.PI*2); let gradSphere = ctx.createRadialGradient(sphere.x-30, sphere.y-30, 10, sphere.x, sphere.y, sphere.r); gradSphere.addColorStop(0, '#f1c40f'); gradSphere.addColorStop(1, '#f39c12'); ctx.fillStyle = gradSphere; ctx.fill(); ctx.lineWidth = 3; ctx.strokeStyle = '#e67e22'; ctx.stroke(); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(sphere.x - 5, sphere.y + sphere.r, 10, 150); ctx.fillStyle = '#95a5a6'; ctx.fillRect(sphere.x - 30, sphere.y + sphere.r + 150, 60, 10); drawLabel(ctx, "é‡‘å±¬çƒ", sphere.x, sphere.y + sphere.r + 175, sNet); ctx.save(); let gradRod = ctx.createLinearGradient(rod.x, 0, rod.x + rod.w, 0); if (rodType === 'glass') { gradRod.addColorStop(0, 'rgba(230, 245, 255, 0.9)'); gradRod.addColorStop(1, 'rgba(200, 230, 255, 0.9)'); } else { gradRod.addColorStop(0, '#7f8c8d'); gradRod.addColorStop(1, '#2c3e50'); } ctx.fillStyle = gradRod; ctx.strokeStyle = '#999'; ctx.lineWidth = 2; roundRect(ctx, rod.x, rod.y, rod.w, rod.h, 15, true, true); drawLabel(ctx, rod.name, rod.x + rod.w/2, rod.y - 30, rNet); ctx.restore(); particles.forEach(p => { p.update(); p.draw(); }); updateGuide(); if (rod.draggable && mousePos.x > rod.x && mousePos.x < rod.x+rod.w && mousePos.y > rod.y && mousePos.y < rod.y+rod.h) { canvas.style.cursor = 'pointer'; } else { canvas.style.cursor = 'default'; } requestAnimationFrame(update); }
function roundRect(ctx, x, y, width, height, radius, fill, stroke) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); if (stroke) ctx.stroke(); if (fill) ctx.fill(); }
function onMouseDown(e) { const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; if (rod.draggable && mx > rod.x && mx < rod.x + rod.w && my > rod.y && my < rod.y + rod.h) { draggingObj = rod; dragOffset.x = mx - rod.x; dragOffset.y = my - rod.y; } }
function onMouseMove(e) { const rect = canvas.getBoundingClientRect(); mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top; if (!draggingObj) return; if (draggingObj === rod) { let desiredX = mousePos.x - dragOffset.x; let desiredY = mousePos.y - dragOffset.y; if(desiredX < 0) desiredX = 0; if(desiredY < 0) desiredY = 0; if(desiredY > canvas.height - rod.h) desiredY = canvas.height - rod.h; let maxRightX = sphere.x - SPHERE_RADIUS + 5; if (desiredX + rod.w > maxRightX) { desiredX = maxRightX - rod.w; } let deltaX = desiredX - rod.x; let deltaY = desiredY - rod.y; rod.x = desiredX; rod.y = desiredY; particles.forEach(p => { if (p.parent === 'rod' && !p.isTransferring) { p.currentX += deltaX; p.currentY += deltaY; } }); } }
function onMouseUp() { draggingObj = null; }
window.onload = function() { init(); };

// --- iPad Touch Event Support ---
canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length > 1) return;
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousedown', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    var touch = e.touches[0];
    var mouseEvent = new MouseEvent('mousemove', {
        bubbles: true, cancelable: true, view: window,
        clientX: touch.clientX, clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});

canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    var mouseEvent = new MouseEvent('mouseup', {
        bubbles: true, cancelable: true, view: window
    });
    window.dispatchEvent(mouseEvent);
}, {passive: false});

</script>
</body>
</html>
    </textarea>

    <!-- 4. ä¸»æ§ç¨‹å¼ç¢¼ -->
    <script>
        const menu = document.getElementById('main-menu');
        const app = document.getElementById('app-container');
        const frame = document.getElementById('experiment-frame');
        const btns = document.querySelectorAll('.nav-btn:not(.home-btn)');

        // è¼‰å…¥æŒ‡å®šå¯¦é©—
        function loadExperiment(id) {
            // 1. åˆ‡æ›é¡¯ç¤ºæ¨¡å¼
            document.body.classList.add('mode-experiment');
            
            // 2. æ›´æ–°åº•éƒ¨å°èˆªæŒ‰éˆ•ç‹€æ…‹
            btns.forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`nav-btn-${id}`);
            if(activeBtn) activeBtn.classList.add('active');

            // 3. å¾ textarea è®€å–åŸå§‹ç¢¼ä¸¦æ³¨å…¥ iframe
            // ä½¿ç”¨ textarea å¯ä»¥å®Œå…¨é¿å… script æ¨™ç±¤è§£æéŒ¯èª¤çš„å•é¡Œ
            const sourceCode = document.getElementById(`code-exp-${id}`).value;
            frame.srcdoc = sourceCode;
        }

        // è¿”å›ä¸»é¸å–®
        function goHome() {
            document.body.classList.remove('mode-experiment');
            // ç¨å¾®å»¶é²å¾Œæ¸…ç©º iframe ä»¥ç¯€çœè³‡æº
            setTimeout(() => { frame.srcdoc = ''; }, 400); 
            btns.forEach(btn => btn.classList.remove('active'));
        }
    </script>
</body>
</html>