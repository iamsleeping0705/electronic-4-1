<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœé›»å­¸äº’å‹•å¯¦é©—å®¤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none; /* é˜²æ­¢åœ¨ iPad ä¸Šæ‹–æ›³æ™‚æ²å‹•é é¢ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f4f8;
            overflow: hidden;
        }
        canvas {
            touch-action: none;
            background: radial-gradient(circle, #ffffff 0%, #e2e8f0 100%);
            border-radius: 1rem;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }
        .btn {
            transition: all 0.2s;
            active: scale-95;
        }
        /* ç°¡å–®çš„é›»è·å‹•ç•« */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col">

    <!-- å°èˆªåˆ— -->
    <nav class="bg-slate-800 text-white p-3 flex justify-between items-center shadow-md z-10 shrink-0">
        <div class="flex items-center gap-2">
            <span class="text-xl font-bold text-yellow-400">âš¡ éœé›»å¯¦é©—å®¤</span>
        </div>
        <div class="flex bg-slate-700 rounded-lg p-1">
            <button id="tab-electroscope" onclick="switchTab('electroscope')" class="px-4 py-2 rounded-md bg-blue-500 text-white font-medium transition-colors">é©—é›»å™¨å¯¦é©—</button>
            <button id="tab-spheres" onclick="switchTab('spheres')" class="px-4 py-2 rounded-md text-slate-300 hover:text-white font-medium transition-colors">é‡‘å±¬çƒå¯¦é©—</button>
        </div>
        <div class="text-xs text-slate-400 hidden sm:block">æ‹–æ›³å¸¶é›»é«”é€²è¡Œå¯¦é©—</div>
    </nav>

    <!-- ä¸»å…§å®¹å€ -->
    <div class="flex-1 relative flex justify-center items-center p-4 overflow-hidden">
        
        <!-- Canvas -->
        <canvas id="simCanvas" class="w-full h-full max-w-4xl max-h-[80vh] border border-slate-300"></canvas>

        <!-- æ§åˆ¶é¢æ¿ (æµ®å‹•) -->
        <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-sm p-4 rounded-xl shadow-xl border border-slate-200 flex gap-4 items-center" id="controls">
            <div id="electroscope-controls" class="flex gap-3">
                <button onclick="resetElectroscope()" class="btn bg-slate-200 text-slate-700 px-4 py-2 rounded-lg font-bold border-b-4 border-slate-300 active:border-b-0 active:translate-y-1">
                    â†º é‡ç½®å¯¦é©—
                </button>
                <button onclick="groundElectroscope()" class="btn bg-green-500 text-white px-4 py-2 rounded-lg font-bold border-b-4 border-green-700 active:border-b-0 active:translate-y-1 flex items-center gap-2">
                    <span>âœ‹</span> æ‰‹æŒ‡æ¥åœ°
                </button>
            </div>
            <div id="spheres-controls" class="hidden gap-3">
                <button onclick="resetSpheres()" class="btn bg-slate-200 text-slate-700 px-4 py-2 rounded-lg font-bold border-b-4 border-slate-300 active:border-b-0 active:translate-y-1">
                    â†º é‡ç½®å¯¦é©—
                </button>
                <div class="text-sm text-slate-500 flex items-center px-2">
                    <span class="mr-2">ğŸ’¡</span> æŠŠæ£’å­é è¿‘å°çƒ
                </div>
            </div>
        </div>

        <!-- æç¤ºæ–‡å­— -->
        <div id="instruction-toast" class="absolute top-4 bg-yellow-100 text-yellow-800 px-4 py-2 rounded-full text-sm font-semibold shadow-md pointer-events-none opacity-80 transition-opacity duration-500">
            è©¦è‘—æ‹–æ›³ç»ç’ƒæ£’é è¿‘é‡‘å±¬ç›¤...
        </div>
    </div>

<script>
/**
 * éœé›»å¯¦é©—æ¨¡æ“¬æ ¸å¿ƒ
 * åŒ…å«å…©å€‹å ´æ™¯ï¼šé©—é›»å™¨ (Electroscope) èˆ‡ é‡‘å±¬çƒ (Spheres)
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
let width, height;
let activeTab = 'electroscope'; // 'electroscope' or 'spheres'
let animationId;

// ç‹€æ…‹è®Šæ•¸ï¼šé©—é›»å™¨
let electroscopeState = {
    rodPos: { x: 0, y: 0 },
    rodDragging: false,
    rodCharge: 1, // æ­£é›»
    scopeCharge: 0, // 0: ä¸­æ€§, >0: æ­£é›», <0: è² é›»
    leafAngle: 0,
    inductionLevel: 0, // æ„Ÿæ‡‰ç¨‹åº¦ (é›»å­è·‘åˆ°ä¸Šé¢çš„é‡)
    isGrounded: false,
    message: "å°‡å¸¶é›»æ£’é è¿‘..."
};

// ç‹€æ…‹è®Šæ•¸ï¼šé‡‘å±¬çƒ
let spheresState = {
    rodPos: { x: 0, y: 0 },
    rodDragging: false,
    sphere1: { angle: 0, charge: 0, x: 0, y: 0 }, // å·¦çƒ
    sphere2: { angle: 0, charge: 0, x: 0, y: 0 }, // å³çƒ
    touched: false
};

// åˆå§‹åŒ–èˆ‡èª¿æ•´å¤§å°
function resize() {
    const parent = canvas.parentElement;
    canvas.width = parent.clientWidth;
    canvas.height = parent.clientHeight;
    width = canvas.width;
    height = canvas.height;
    
    // é‡ç½®æ£’å­ä½ç½®åˆ°å³å´
    electroscopeState.rodPos = { x: width * 0.8, y: height * 0.3 };
    spheresState.rodPos = { x: width * 0.8, y: height * 0.5 };
}
window.addEventListener('resize', resize);
resize();

// åˆ‡æ›åˆ†é 
function switchTab(tab) {
    activeTab = tab;
    document.getElementById('tab-electroscope').className = tab === 'electroscope' ? 
        'px-4 py-2 rounded-md bg-blue-500 text-white font-medium transition-colors' : 
        'px-4 py-2 rounded-md text-slate-300 hover:text-white font-medium transition-colors';
    document.getElementById('tab-spheres').className = tab === 'spheres' ? 
        'px-4 py-2 rounded-md bg-blue-500 text-white font-medium transition-colors' : 
        'px-4 py-2 rounded-md text-slate-300 hover:text-white font-medium transition-colors';
    
    document.getElementById('electroscope-controls').style.display = tab === 'electroscope' ? 'flex' : 'none';
    document.getElementById('spheres-controls').style.display = tab === 'spheres' ? 'flex' : 'none';

    updateInstruction(tab === 'electroscope' ? "è©¦è‘—æ‹–æ›³ç»ç’ƒæ£’é è¿‘é‡‘å±¬ç›¤..." : "å°‡å¸¶é›»æ£’é è¿‘å°çƒè§€å¯Ÿå¸å¼•èˆ‡æ’æ–¥...");
    
    if(tab === 'electroscope') resetElectroscope();
    else resetSpheres();
}

function updateInstruction(text) {
    const el = document.getElementById('instruction-toast');
    el.innerText = text;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 4000);
}

// --------------------------------------------------------
// ç‰©ç†èˆ‡ç¹ªåœ–é‚è¼¯ï¼šé€šç”¨
// --------------------------------------------------------

function drawPlus(x, y, size=10, color='red') {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - size/2, y);
    ctx.lineTo(x + size/2, y);
    ctx.moveTo(x, y - size/2);
    ctx.lineTo(x, y + size/2);
    ctx.stroke();
}

function drawMinus(x, y, size=10, color='blue') {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - size/2, y);
    ctx.lineTo(x + size/2, y);
    ctx.stroke();
}

function drawRod(x, y, angle = -Math.PI / 4) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    // ç»ç’ƒæ£’æœ¬é«”
    const grad = ctx.createLinearGradient(-10, 0, 10, 0);
    grad.addColorStop(0, 'rgba(200, 240, 255, 0.8)');
    grad.addColorStop(0.5, 'rgba(240, 250, 255, 0.9)');
    grad.addColorStop(1, 'rgba(180, 230, 255, 0.8)');
    
    ctx.fillStyle = grad;
    ctx.strokeStyle = '#8ecae6';
    ctx.lineWidth = 2;
    
    // åœ“è§’é•·æ–¹å½¢
    ctx.beginPath();
    ctx.roundRect(-15, -100, 30, 200, 15);
    ctx.fill();
    ctx.stroke();

    // é›»è· (æ­£é›»)
    for(let i = -80; i < 90; i+=30) {
        drawPlus(0, i, 12, 'rgba(255, 100, 100, 0.8)');
    }

    ctx.restore();
}

// --------------------------------------------------------
// å ´æ™¯ 1ï¼šé©—é›»å™¨ (Electroscope)
// --------------------------------------------------------

function resetElectroscope() {
    electroscopeState.scopeCharge = 0;
    electroscopeState.leafAngle = 0;
    electroscopeState.inductionLevel = 0;
    electroscopeState.isGrounded = false;
    electroscopeState.rodPos = { x: width * 0.8, y: height * 0.3 };
    updateInstruction("å¯¦é©—å·²é‡ç½®ã€‚å¸¶é›»æ£’å¸¶æ­£é›»ã€‚");
}

function groundElectroscope() {
    electroscopeState.isGrounded = true;
    setTimeout(() => { electroscopeState.isGrounded = false; }, 1000); // 1ç§’å¾Œæ”¾é–‹
    // æ¥åœ°ç¬é–“ï¼Œå¦‚æœæ£’å­åœ¨é™„è¿‘ï¼ˆæ„Ÿæ‡‰ä¸­ï¼‰ï¼Œé›»å­æœƒæµä¸Šä¾†ä¸­å’Œæ­£é›»ï¼Œå°è‡´ç§»é–‹æ£’å­å¾Œå¸¶è² é›»
    // é€™è£¡ç°¡åŒ–æ¨¡æ“¬ï¼šæ¥åœ°è®“é‡‘ç®”é–‰åˆï¼ˆé›»ä½ç‚º0ï¼‰ï¼Œé›»è·è¢«ä¸­å’Œ
    electroscopeState.scopeCharge = 0; 
    updateInstruction("æ‰‹è§¸ç¢°é‡‘å±¬ç›¤ï¼šé›»å­æµå…¥ï¼Œé›»è·ä¸­å’Œã€‚");
}

function updateElectroscope() {
    const centerX = width / 2;
    const centerY = height * 0.6;
    const topPlateY = centerY - 150;
    
    // 1. è¨ˆç®—æ£’å­èˆ‡é‡‘å±¬ç›¤çš„è·é›¢
    // æ£’å­ç†±é»å¤§æ¦‚åœ¨å·¦ä¸Šè§’
    const rodTipX = electroscopeState.rodPos.x - 40; 
    const rodTipY = electroscopeState.rodPos.y + 40;
    
    const dist = Math.hypot(rodTipX - centerX, rodTipY - topPlateY);
    const maxDist = 300;
    
    // 2. æ¥è§¸åˆ¤æ–·
    const isTouching = dist < 50;

    // 3. ç‰©ç†é‚è¼¯
    if (electroscopeState.isGrounded) {
        // æ¥åœ°æ™‚ï¼Œé‡‘ç®”ä¸å¸¶é›»ï¼Œé›»è·æ­¸é›¶ (æˆ–è¦–æ„Ÿæ‡‰æƒ…æ³ï¼Œé€™è£¡ç°¡åŒ–ç‚ºæ­¸é›¶é–‰åˆ)
        electroscopeState.inductionLevel = 0;
        electroscopeState.leafAngle = 0;
        if (!isTouching) {
             // å¦‚æœæ²’æ¥è§¸æ£’å­ï¼Œæ¥åœ°å°±æ˜¯å®Œå…¨ä¸­å’Œ
             electroscopeState.scopeCharge = 0;
        }
    } else {
        if (isTouching) {
            // æ¥è§¸èµ·é›»ï¼šé›»å­è¢«æ£’å­å¸èµ°ï¼Œé©—é›»å™¨å¸¶æ­£é›»
            if (electroscopeState.scopeCharge <= 0) {
                electroscopeState.scopeCharge = 0.8; // è®Šæˆæ­£é›»
                updateInstruction("æ¥è§¸ï¼é›»å­è¢«å¸åˆ°æ£’å­ä¸Šï¼Œé©—é›»å™¨ç¾åœ¨å¸¶æ­£é›»ã€‚");
            }
            electroscopeState.inductionLevel = 0; // æ¥è§¸æ™‚è¦–ç‚ºä¸€é«”ï¼Œä¸å†å¼·èª¿æ„Ÿæ‡‰åˆ†é›¢
        } else {
            // æ„Ÿæ‡‰èµ·é›»ï¼šè·é›¢è¶Šè¿‘ï¼Œåˆ†é›¢è¶Šå¼·
            // inductionLevel ä»£è¡¨é›»å­è·‘åˆ°ä¸Šé¢çš„æ¯”ä¾‹ (0~1)
            let effect = Math.max(0, 1 - (dist / maxDist));
            electroscopeState.inductionLevel = effect * 1.5; // ä¿‚æ•¸æ”¾å¤§æ•ˆæœ
        }

        // è¨ˆç®—é‡‘ç®”è§’åº¦
        // è§’åº¦å–æ±ºæ–¼ï¼šæ·¨é›»è· + æ„Ÿæ‡‰åˆ°åº•éƒ¨çš„é›»è·
        // å¦‚æœå¸¶æ­£é›» (scopeCharge > 0)ï¼Œåº•éƒ¨æ›´æ­£ã€‚
        // å¦‚æœä¸­æ€§ä½†æ„Ÿæ‡‰ (induction > 0)ï¼Œåº•éƒ¨å› é›»å­è·‘ä¸Šå»è€Œè®Šæ­£ã€‚
        // ç¸½ä¹‹ï¼Œåº•éƒ¨æ­£é›»è·é‡ = scopeCharge + (inductionLevel * factor)
        // è¨»ï¼šé€™æ˜¯ä¸€å€‹è¦–è¦ºæ¨¡æ“¬ï¼Œéåš´æ ¼å®šé‡è¨ˆç®—
        
        let bottomPositiveCharge = electroscopeState.scopeCharge + (electroscopeState.inductionLevel * 0.5);
        
        // é™åˆ¶ç¯„åœ
        if(bottomPositiveCharge < 0) bottomPositiveCharge = 0; // æš«ä¸æ¨¡æ“¬è² é›»æ£’æƒ…æ³
        
        let targetAngle = Math.min(Math.PI / 2.5, bottomPositiveCharge * 1.2);
        
        // å¹³æ»‘å‹•ç•«
        electroscopeState.leafAngle += (targetAngle - electroscopeState.leafAngle) * 0.1;
    }
}

function drawElectroscopeScene() {
    const centerX = width / 2;
    const centerY = height * 0.6;
    const topPlateY = centerY - 150;

    // ç•«ç“¶å­
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 4;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.beginPath();
    ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // ç“¶åº•åº•åº§
    ctx.fillStyle = '#475569';
    ctx.fillRect(centerX - 60, centerY + 90, 120, 20);

    // é‡‘å±¬æ¡¿
    ctx.fillStyle = '#cbd5e1';
    ctx.fillRect(centerX - 5, topPlateY, 10, 150);

    // é‡‘å±¬ç›¤ (Top)
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.ellipse(centerX, topPlateY, 60, 15, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // é‡‘ç®” (Leaves)
    ctx.save();
    ctx.translate(centerX, centerY);
    
    // å·¦é‡‘ç®”
    ctx.fillStyle = '#fbbf24'; // Gold
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.rotate(-electroscopeState.leafAngle / 2); // åˆ†é–‹
    ctx.fillRect(-2, 0, 4, 80);
    // é‡‘ç®”ä¸Šçš„é›»è· (æ­£é›»)
    if (electroscopeState.leafAngle > 0.1) {
        drawPlus(0, 60, 8, '#b45309');
    }
    ctx.rotate(electroscopeState.leafAngle / 2); // å¾©åŸ

    // å³é‡‘ç®”
    ctx.rotate(electroscopeState.leafAngle / 2);
    ctx.fillRect(-2, 0, 4, 80);
    if (electroscopeState.leafAngle > 0.1) {
        drawPlus(0, 60, 8, '#b45309');
    }
    ctx.restore();

    // ç¹ªè£½é›»è·åˆ†å¸ƒ (é›»å­ç§»å‹•å‹•ç•«)
    // ç›¤å­ä¸Šçš„é›»è·
    // å¦‚æœæ„Ÿæ‡‰å¼·ï¼Œé›»å­(è² )å¤š
    // å¦‚æœæœ¬èº«å¸¶æ­£é›»ï¼Œé›»å­å°‘(æˆ–æ˜¯ç•«æ­£è™Ÿ)
    
    let electronCount = Math.floor(electroscopeState.inductionLevel * 8); 
    // å¦‚æœå¸¶æ­£é›»ï¼Œé¡¯ç¤ºæ­£è™Ÿåœ¨ç›¤å­ä¸Š
    // å¦‚æœæ„Ÿæ‡‰ï¼Œé¡¯ç¤ºè² è™Ÿåœ¨ç›¤å­ä¸Š
    
    if (electroscopeState.scopeCharge > 0.1) {
        // æ•´é«”æ­£é›»
        drawPlus(centerX, topPlateY, 12);
        drawPlus(centerX - 20, topPlateY, 12);
        drawPlus(centerX + 20, topPlateY, 12);
    } else if (electronCount > 0) {
        // æ„Ÿæ‡‰ä¸­ï¼šé¡¯ç¤ºé›»å­è¢«å¸ä¸Šä¾†
        ctx.font = "20px Arial";
        ctx.fillStyle = "blue";
        for(let i=0; i<electronCount; i++) {
            let offset = (i - electronCount/2) * 15;
            drawMinus(centerX + offset, topPlateY, 12);
        }
        
        // ç•«å‡ºé›»å­æµå‹•çš„è·¯å¾‘ (è¦–è¦ºè¼”åŠ©)
        ctx.strokeStyle = "rgba(0, 0, 255, 0.2)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX, topPlateY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // æ‰‹æ¥åœ°å‹•ç•«
    if (electroscopeState.isGrounded) {
        ctx.font = "40px Arial";
        ctx.fillText("âœ‹", centerX + 50, topPlateY);
        
        // é›»å­æµå‹•ç®­é ­ (å¾åœ°åˆ°ç›¤)
        ctx.fillStyle = "blue";
        ctx.font = "20px Arial";
        ctx.fillText("eâ»", centerX + 70, topPlateY + 30);
        ctx.beginPath();
        ctx.moveTo(centerX + 80, topPlateY + 60);
        ctx.lineTo(centerX + 60, topPlateY + 20);
        ctx.strokeStyle = "blue";
        ctx.stroke();
    }
    
    // ç•«æ£’å­
    drawRod(electroscopeState.rodPos.x, electroscopeState.rodPos.y);
}

// --------------------------------------------------------
// å ´æ™¯ 2ï¼šé‡‘å±¬çƒ (Spheres)
// --------------------------------------------------------

function resetSpheres() {
    spheresState.sphere1 = { angle: 0, charge: 0, x: 0, y: 0 };
    spheresState.sphere2 = { angle: 0, charge: 0, x: 0, y: 0 };
    spheresState.touched = false;
    spheresState.rodPos = { x: width * 0.8, y: height * 0.5 };
    updateInstruction("é‡ç½®å®Œæˆã€‚è«‹ç·©æ…¢ç§»å‹•å¸¶é›»æ£’é è¿‘å°çƒã€‚");
}

function updateSpheres() {
    const anchorX = width / 2;
    const anchorY = height * 0.2;
    const stringLen = 200;
    
    // æ£’å­ä½ç½® (æ„Ÿæ‡‰æº)
    const rodX = spheresState.rodPos.x - 30; // æ ¡æ­£å°–ç«¯
    const rodY = spheresState.rodPos.y + 30;

    const distToAnchor = Math.hypot(rodX - anchorX, rodY - (anchorY + stringLen));
    
    // ç°¡å–®ç‰©ç†ç‹€æ…‹æ©Ÿ
    // 1. å¸å¼•éšæ®µ (æœªæ¥è§¸)
    if (!spheresState.touched) {
        if (distToAnchor < 250) {
            // é è¿‘äº†ï¼šæ„Ÿæ‡‰å¸å¼•
            // å…©çƒä¸€èµ·å¾€æ£’å­æ–¹å‘æ“º
            let angleToRod = Math.atan2(rodX - anchorX, rodY - anchorY);
            // é™åˆ¶æœ€å¤§æ“ºè§’
            let targetAngle = angleToRod * 0.8; 
            
            // å…©çƒç¨å¾®åˆ†é–‹ä¸€é»é» (æ¥µåŒ–)
            spheresState.sphere1.angle += (targetAngle - 0.05 - spheresState.sphere1.angle) * 0.1;
            spheresState.sphere2.angle += (targetAngle + 0.05 - spheresState.sphere2.angle) * 0.1;
            
            // åˆ¤æ–·æ¥è§¸
            // è¨ˆç®—çƒçš„ä½ç½®
            let s2x = anchorX + Math.sin(spheresState.sphere2.angle) * stringLen;
            let s2y = anchorY + Math.cos(spheresState.sphere2.angle) * stringLen;
            let distToRodTip = Math.hypot(rodX - s2x, rodY - s2y);
            
            if (distToRodTip < 40) {
                spheresState.touched = true;
                spheresState.sphere1.charge = 1;
                spheresState.sphere2.charge = 1;
                updateInstruction("æ¥è§¸ï¼é›»è·è½‰ç§»ï¼Œå…©çƒå¸¶åŒæ€§é›»ï¼Œé–‹å§‹æ’æ–¥ï¼");
            }
        } else {
            // é é›¢ï¼šå›æ­¸å‚ç›´
            spheresState.sphere1.angle *= 0.9;
            spheresState.sphere2.angle *= 0.9;
        }
    } else {
        // 2. æ’æ–¥éšæ®µ (å·²æ¥è§¸å¸¶é›»)
        // çƒå¸¶æ­£é›»ï¼Œæ£’å­å¸¶æ­£é›» -> äº’ç›¸æ’æ–¥
        // çƒä¹‹é–“ä¹Ÿæ’æ–¥
        
        let baseRepulsion = 0.3; // çƒä¹‹é–“çš„æ’æ–¥åŠè§’
        
        // æ£’å­å°çƒçš„æ–¥åŠ›
        let rodRepel = 0;
        if (distToAnchor < 400) {
            rodRepel = (400 - distToAnchor) / 400 * 0.5; // è¶Šè¿‘æ¨è¶Šé 
        }
        
        // åˆ¤æ–·æ£’å­åœ¨å“ªé‚Š
        let rodSide = (rodX > anchorX) ? -1 : 1; // æ£’åœ¨å³é‚Šï¼Œçƒå¾€å·¦èº²
        
        let targetAngle1 = -baseRepulsion + (rodRepel * rodSide);
        let targetAngle2 = baseRepulsion + (rodRepel * rodSide);
        
        spheresState.sphere1.angle += (targetAngle1 - spheresState.sphere1.angle) * 0.05;
        spheresState.sphere2.angle += (targetAngle2 - spheresState.sphere2.angle) * 0.05;
    }
}

function drawSpheresScene() {
    const anchorX = width / 2;
    const anchorY = height * 0.2;
    const stringLen = 200;

    // å¤©èŠ±æ¿
    ctx.fillStyle = '#cbd5e1';
    ctx.fillRect(anchorX - 100, anchorY - 10, 200, 10);
    
    // è¨ˆç®—çƒä½ç½®
    let s1x = anchorX + Math.sin(spheresState.sphere1.angle) * stringLen;
    let s1y = anchorY + Math.cos(spheresState.sphere1.angle) * stringLen;
    
    let s2x = anchorX + Math.sin(spheresState.sphere2.angle) * stringLen;
    let s2y = anchorY + Math.cos(spheresState.sphere2.angle) * stringLen;
    
    // ç•«ç·š
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(anchorX, anchorY);
    ctx.lineTo(s1x, s1y);
    ctx.moveTo(anchorX, anchorY);
    ctx.lineTo(s2x, s2y);
    ctx.stroke();
    
    // ç•«çƒ 1
    ctx.fillStyle = '#94a3b8'; // Metal color
    ctx.beginPath();
    ctx.arc(s1x, s1y, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // ç•«çƒ 2
    ctx.beginPath();
    ctx.arc(s2x, s2y, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    
    // ç•«çƒä¸Šçš„é›»è·
    if (!spheresState.touched) {
        // æœªæ¥è§¸ï¼Œæ„Ÿæ‡‰æ™‚
        // é è¿‘æ£’å­çš„é‚£ä¸€å´å¸¶è² é›»ï¼Œé é›¢å¸¶æ­£é›» (æ¥µåŒ–)
        // é€™è£¡ç°¡åŒ–é¡¯ç¤ºï¼šå¦‚æœè¢«å¸å¼•ï¼Œé¡¯ç¤ºæ„Ÿæ‡‰é›»è·
        const rodX = spheresState.rodPos.x - 30;
        const dist = Math.hypot(rodX - anchorX, spheresState.rodPos.y - (anchorY+200));
        
        if (dist < 250) {
            // é è¿‘æ£’å­(å³å´çƒ)çš„å³é‚Šç•«è² è™Ÿ
            drawMinus(s2x + 10, s2y, 8, 'blue');
            drawPlus(s1x - 10, s1y, 8, 'red');
        }
    } else {
        // å·²æ¥è§¸ï¼Œå¸¶æ­£é›»
        drawPlus(s1x, s1y, 10, 'red');
        drawPlus(s2x, s2y, 10, 'red');
    }

    // ç•«æ£’å­
    drawRod(spheresState.rodPos.x, spheresState.rodPos.y);
}

// --------------------------------------------------------
// ä¸»è¿´åœˆ
// --------------------------------------------------------

function loop() {
    ctx.clearRect(0, 0, width, height);

    if (activeTab === 'electroscope') {
        updateElectroscope();
        drawElectroscopeScene();
    } else {
        updateSpheres();
        drawSpheresScene();
    }
    
    requestAnimationFrame(loop);
}
loop();

// --------------------------------------------------------
// äº’å‹•æ§åˆ¶ (Touch & Mouse)
// --------------------------------------------------------

function handleStart(x, y) {
    // æª¢æŸ¥æ˜¯å¦é»åˆ°æ£’å­
    let rodX, rodY;
    if (activeTab === 'electroscope') {
        rodX = electroscopeState.rodPos.x;
        rodY = electroscopeState.rodPos.y;
    } else {
        rodX = spheresState.rodPos.x;
        rodY = spheresState.rodPos.y;
    }
    
    // ç°¡å–®çš„ç¢°æ’æª¢æ¸¬ (ç¯„åœå¯¬é¬†ä¸€é»æ–¹ä¾¿æ‰‹æŒ‡æ“ä½œ)
    if (Math.hypot(x - rodX, y - rodY) < 150) {
        if (activeTab === 'electroscope') electroscopeState.rodDragging = true;
        else spheresState.rodDragging = true;
    }
}

function handleMove(x, y) {
    if (activeTab === 'electroscope' && electroscopeState.rodDragging) {
        electroscopeState.rodPos.x = x;
        electroscopeState.rodPos.y = y;
    } else if (activeTab === 'spheres' && spheresState.rodDragging) {
        spheresState.rodPos.x = x;
        spheresState.rodPos.y = y;
    }
}

function handleEnd() {
    electroscopeState.rodDragging = false;
    spheresState.rodDragging = false;
}

// Mouse Events
canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    handleStart(e.clientX - rect.left, e.clientY - rect.top);
});
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    handleMove(e.clientX - rect.left, e.clientY - rect.top);
});
window.addEventListener('mouseup', handleEnd);

// Touch Events
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    handleStart(touch.clientX - rect.left, touch.clientY - rect.top);
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault(); // é˜»æ­¢æ»¾å‹•
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    handleMove(touch.clientX - rect.left, touch.clientY - rect.top);
}, {passive: false});

canvas.addEventListener('touchend', handleEnd);

</script>
</body>
</html>